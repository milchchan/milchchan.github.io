<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-617KR1WTYP"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-617KR1WTYP");
    </script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f4f4f2" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#f4f4f2" />
    <title>ABOUT MILCHCHAN.COM</title>
    <link rel="icon" type="image/png" href="favicon.png" />
    <link rel="apple-touch-icon" href="touch-icon-iphone.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="touch-icon-iphone-retina.png" />
    <link rel="apple-touch-icon" sizes="167x167" href="touch-icon-ipad-retina.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@400;700&display=swap" rel="stylesheet" />
    <script src="https://kit.fontawesome.com/922939073a.js" crossorigin="anonymous"></script>
    <style media="screen">
      :root {
        --background-color: #ffffff;
        --foreground-color: #000000;
        --milch-light-background-image: /images/Milchchan.png;
        --milch-dark-background-image: /images/Background-Milch-Zankuro-1.png;
        --merku-light-background-image: /images/Merkuchan.png;
        --merku-dark-background-image: /images/Background-Merku-Zankuro-1.png;
        --story-light-background-image: /images/Milch-Manga-01.png;
        --story-dark-background-image: /images/Milch-Manga-02.png;
      }

      html {
        touch-action: none;
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100vh;
        height: 100dvh;
        overflow-x: hidden;
        overflow-y: auto;
        scroll-behavior: smooth;
        background: #f4f4f2;
      }

      body {
        position: relative;
        margin: 0;
        padding: 0;
        width: 100%;
        min-height: 100vh;
        min-height: -webkit-fill-available;
        min-height: 100dvh;
        overflow: hidden;
      }

      h1 {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: flex-start;
        margin: 0px -4px 0px -4px !important;
        padding: 0;
        color: var(--foreground-color) !important;
        font-family: "Barlow", "Roboto", "Helvetica", "Segoe UI", "Arial", sans-serif;
        font-size: 2rem;
        font-weight: bold;
        line-height: 2rem;
        text-transform: uppercase;
      }

      h1>span {
        margin: 0px 4px 0px 4px !important;
      }

      h2 {
        position: sticky;
        top: 0px;
        margin: 0;
        padding: 0;
        color: var(--foreground-color) !important;
        font-family: "Barlow", "Roboto", "Helvetica", "Segoe UI", "Arial", sans-serif;
        font-size: 0.75rem;
        font-weight: bold;
        line-height: 0.75rem;
        text-transform: uppercase;
      }

      h1+h2 {
        margin: 8px 0px 0px 0px;
      }

      p+h2 {
        margin: 16px 0px 0px 0px;
      }

      p {
        margin: 16px 0px 0px 0px;
        padding: 0;
        color: var(--foreground-color) !important;
        font-family: "Barlow", "Roboto", "Helvetica", "Segoe UI", "Arial", sans-serif;
        font-size: 1.25rem;
        line-height: 2rem;
      }

      ul,
      ol {
        margin-left: 0;
        padding-left: 0;
      }

      ul {
        margin: 16px 0px 0px 0px;
      }

      ul>li {
        margin: 0px 0px 0px 16px;
        padding: 0;
        list-style-type: none;
        color: var(--foreground-color) !important;
        font-family: "Barlow", "Roboto", "Helvetica", "Segoe UI", "Arial", sans-serif;
        font-size: 1.25rem;
        line-height: 2rem;
      }

      a,
      a:focus,
      a:link,
      a:visited,
      a:hover,
      a:active {
        outline: none;
        text-decoration: none;
        color: var(--foreground-color);
      }

      a .scrollable {
        display: inline-block;
        box-sizing: content-box;
        backface-visibility: hidden;
        transform: translate3d(0%, 0%, 0);
        transition: 0.5s ease-in;
      }

      a .scrollable>div {
        -webkit-user-select: none;
        user-select: none;
        box-sizing: content-box;
        vertical-align: middle;
      }

      a .scrollable:hover {
        display: inline-block;
        box-sizing: content-box;
        backface-visibility: hidden;
        transform: translate3d(-100%, 0%, 0);
        transition: 0.5s ease-out;
      }

      .is-hidden {
        display: none !important;
      }

      .is-uppercase {
        text-transform: uppercase;
      }

      .is-italic {
        font-style: italic;
      }

      .has-text-weight-bold {
        font-weight: bold;
      }

      body>.wrap {
        position: absolute;
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        min-height: 100%;
        overflow: hidden;
        box-sizing: border-box;
        backface-visibility: hidden;
        transition: 0.5s;
      }

      body>.wrap>.frame {
        position: relative;
        margin: 0;
        padding: 0;
        border-radius: 0px;
        width: 100%;
        max-width: 100% !important;
        height: 100%;
        overflow: hidden;
        background-color: #f4f4f2;
        transition: 0.5s;
      }

      .background {
        -webkit-user-select: none;
        user-select: none;
        position: absolute;
        top: 16px;
        margin: 0;
        padding: 0;
        width: 100%;
        max-width: 100%;
        height: calc(100% - 32px);
        max-height: 100%;
        background-color: transparent;
        background-position: 50% 50%;
        background-repeat: no-repeat;
        background-attachment: scroll;
        background-size: contain;
        transform-origin: 50% 50%;
        backface-visibility: hidden;
        perspective: 1000;
      }

      .background::before {
        -webkit-user-select: none;
        user-select: none;
        position: absolute;
        margin: 0;
        padding: 0;
        width: 100%;
        max-width: 100%;
        height: 100%;
        max-height: 100%;
        overflow: hidden;
        background: transparent;
        content: "";
      }

      .background>div {
        -webkit-user-select: none;
        user-select: none;
        position: relative;
        opacity: 0.5;
        margin: 0;
        padding: 0;
        width: 100%;
        max-width: 100%;
        height: 100%;
        max-height: 100%;
        overflow: hidden;
        background-color: transparent;
        background-position: 50% 50%;
        background-repeat: no-repeat;
        background-attachment: scroll;
        background-size: contain;
        transform-origin: 50% 50%;
        backface-visibility: hidden;
        content: "";
        transition: .5s;
      }

      .background>div.is-touching {
        opacity: 0.5;
        transition: .5s;
      }

      .overlay {
        position: absolute;
        left: 0;
        top: 0;
        margin: 0;
        padding: 16px;
        width: 100%;
        height: 100%;
        min-height: 100%;
        overflow-x: hidden;
        overflow-y: auto;
        mask-image: linear-gradient(to bottom, transparent, black 16px, black calc(100% - 16px), transparent), linear-gradient(black, black);
        mask-size: calc(100% - 16px) 100%, 16px 100%;
        mask-position: 0 0, 100% 0;
        mask-repeat: no-repeat, no-repeat;
        animation: fade .5s ease-out forwards;
        box-sizing: border-box;
        backface-visibility: hidden;
        perspective: 1000;
        transition: 0.5s;
      }

      .overlay>.wrap {
        position: relative;
        box-sizing: border-box;
        margin: 0px 0px 0px calc(48px - 16px);
        padding: max(env(safe-area-inset-top, 0px), env(safe-area-inset-bottom, 0px)) max(env(safe-area-inset-right, 0px), env(safe-area-inset-left, 0px));
      }

      .overlay>.wrap>.content {
        position: absolute;
        margin: 0;
        padding: 0px 0px 16px 0px;
        width: 100%;
        transition: padding 0.5s;
        cursor: default;
      }

      .content p+div {
        margin: 16px 0px 0px 0px;
      }

      .content div+div {
        margin: 16px 0px 0px 0px;
      }

      .content>div:last-of-type {
        margin: 0 !important;
      }

      .content p a {
        display: inline;
        margin: 0;
        padding: 0;
        border: 0px solid transparent;
        background: transparent;
        background-clip: padding-box;
        backface-visibility: hidden;
        cursor: pointer;
      }

      .content p a .clip {
        position: relative;
        display: inline-flex;
        overflow: hidden;
        box-sizing: border-box;
      }

      .content p a .scrollable {
        display: inline-flex;
        margin: 0px -4px 0px -4px !important;
      }

      .content p a .scrollable span {
        display: inline;
        margin: 0px 4px 0px 4px !important;
        font-family: "Barlow", "Roboto", "Helvetica", "Segoe UI", "Arial", sans-serif;
        line-height: normal;
      }

      .content p a .scrollable span:last-child:not(:first-child) {
        position: absolute;
        left: 100%;
      }
      
      .overlay>.wrap>.content .icon.is-animatable {
        position: fixed;
        right: 16px;
      }

      div.sidebar {
        -webkit-user-select: none;
        user-select: none;
        z-index: 0;
        position: fixed;
        left: 0px;
        padding: env(safe-area-inset-top, 0px) 0px env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
        height: calc(100% - 32px);
        background: transparent;
        transition: 0.5s;
      }

      div.sidebar .separator {
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        justify-content: center;
        width: 48px;
        height: fit-content;
      }

      div.sidebar .separator>hr {
        border-width: 0;
        margin: 0;
        padding: 0;
        width: 16px;
        height: 1px;
        background-color: #000000;
        text-align: center !important;
      }

      div.sidebar .button.is-selected .wrap {
        border-bottom: 2px solid #000000;
        transition: .5s ease-in;
      }

      div.sidebar .rotation-outer {
        display: inline-flex;
      }

      div.sidebar .rotation-outer>div.rotation-inner {
        padding: 50% 0;
        height: 0;
      }

      div.sidebar .rotation-outer>div.rotation-inner>div.rotate {
        display: block;
        transform-origin: top left;
        transform: rotate(-90deg) translate(0%, 100%) rotate(180deg);
        margin-top: -50%;
        white-space: nowrap;
      }

      div.sidebar>.level {
        display: flex;
        margin: 0;
        padding: 0;
        width: 48px;
        height: 100%;
        flex-direction: column;
        align-items: flex-start;
        justify-content: space-between;
      }

      div.sidebar>.level>.level-item>.level {
        display: flex;
        margin: -16px;
        padding: 0;
        flex-direction: column;
        align-items: flex-start;
        justify-content: space-between;
      }

      div.sidebar>.level>.level-item>.level>.level-item {
        display: flex;
        margin: 0;
        padding: 16px;
      }

      div.sidebar>.level>.level-item>.level>.level-item .icon {
        transform: rotate(-90deg);
      }

      div.sidebar .level>.level-item {
        margin: 0;
        padding: 0;
      }

      div.sidebar .button {
        display: flex;
        margin: 0;
        padding: 0;
        border: 0px solid transparent;
        background: transparent;
        background-clip: padding-box;
        line-height: calc(0.75rem * 1.5);
        backface-visibility: hidden;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        width: fit-content;
        height: 48px;
        cursor: pointer;
      }

      div.sidebar .button {
          opacity: 1.0;
          transition: .5s;
      }

      div.sidebar .button .icon {
        margin: 0;
        padding: 0;
        width: 0.5rem;
        height: 0.5rem;
        font-size: 0.5rem;
        line-height: 0;
        transition: .5s;
      }

      div.sidebar .button.is-animatable:hover {
        opacity: 0.5;
        transition: .5s;
      }

      div.sidebar .button:disabled {
          opacity: 0.5 !important;
          transition: .5s;
      }

      div.sidebar .button:disabled .icon.is-rotatable {
        animation: loading 1s linear forwards infinite;
        animation-play-state: running;
      }

      div.sidebar .button.is-recording .icon {
        animation: processing 1s linear forwards infinite;
        animation-play-state: running;
      }

      div.sidebar .button .clip {
        position: relative;
        display: flex;
        overflow: hidden;
        height: calc(0.75rem * 1.5);
        box-sizing: border-box;
      }

      div.sidebar .button .scrollable {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: flex-start;
        margin: 0px -4px 0px -4px !important;
        transform: translate3d(0%, 0%, 0);
        transition: 0.5s ease-in;
      }

      div.sidebar .button .scrollable:hover {
        transform: translate3d(-100%, 0%, 0);
        transition: 0.5s ease-out;
      }

      div.sidebar .button .scrollable div {
        display: flex;
        align-items: center;
        margin: 0px 4px 0px 4px !important;
        font-family: "Barlow", "Roboto", "Helvetica", "Segoe UI", "Arial", sans-serif;
        font-size: 0.75rem !important;
        line-height: 0.75rem !important;
        height: calc(0.75rem * 1.5);
        vertical-align: middle;
      }

      div.sidebar .button .scrollable div:last-child:not(:first-child) {
        position: absolute;
        left: 100%;
      }

      div.sidebar .button .wrap {
        position: relative;
        display: flex;
        margin: 0;
        border-top: 2px solid transparent;
        border-bottom: 2px solid transparent;
        color: #000000;
        width: fit-content;
        height: fit-content;
        min-height: fit-content;
        box-sizing: border-box;
        overflow: hidden;
        justify-content: flex-start;
        align-items: center;
        transform: translate3d(0, 0, 0);
        transition: 0.5s;
      }

      .icon {
        display: inline-block;
        justify-items: center;
        margin: 0;
        padding: 0;
        color: #000000;
        width: fit-content;
        height: fit-content;
        transition: .5s;
        line-height: 0;
        align-items: center;
        justify-content: center;
      }

      .icon figure {
        margin: 0;
      }

      .button>figure {
        opacity: 1;
        transition: .5s;
      }

      .button:hover>figure {
        opacity: 0.5;
        transition: .5s;
      }

      .icon figure>picture {
        display: block;
      }

      .icon:first-child+div,
      .icon:not(:first-of-type) {
        margin: 0px 0px 0px 16px;
      }

      .icon.is-animatable figure {
        display: flex;
        justify-content: flex-start;
        align-items: flex-start;
        overflow: hidden;
        width: 32px;
        height: 32px;
      }

      .icon.is-animatable figure>picture {
        margin-left: 0%;
        width: auto;
        height: 100%;
        animation: frame 1.33s steps(4) infinite forwards;
      }

      .icon.is-animatable figure>picture>img {
        object-fit: none;
        object-position: 0% 0%;
        width: 100%;
        height: 100%;
      }

      .content .reveal {
        color: #0000;
        background: linear-gradient(var(--foreground-color) 0 0) no-repeat, linear-gradient(var(--foreground-color) 0 0) no-repeat;
        background-clip: padding-box, text;
        background-size: 0% 100%;
        animation: mask 1.0s ease 0.5s both, reveal 1.0s ease 1.5s both;
      }

      .content>div>div>div.is-playable {
        opacity: 1.0;
        backface-visibility: hidden;
        transition: opacity .5s;
      }

      .content>div>div>div.is-playable:hover {
        cursor: pointer;
        opacity: 0.5;
        transition: .5s;
      }

      .content>div>div>div.is-playable>p.is-generated {
        opacity: 1.0;
        transition: .5s;
      }

      .content>div>div>div.is-playable>p.is-generated.is-loading {
        animation: processing 1s linear forwards infinite;
        animation-play-state: running;
      }

      #apricot:not(.is-active) {
        opacity: 0;
        transition: .5s;
      }

      #apricot.is-active {
        opacity: 1;
        transition: .5s;
      }

      #apricot canvas.likability {
        background: rgb(255 255 255 / 1.0) !important;
      }

      #apricot div.popup {
        background: rgb(255 255 255 / 1.0) !important;
        box-shadow: 0 .5em 1em -.125em #0a0a0a1a, 0 0 0 1px #0a0a0a05 !important;
      }

      #apricot div.popup::before {
        content: '';
        position: absolute;
        width: 100%;
        height: 100%;
        background: linear-gradient(to right, transparent 0%, rgb(255 255 255 / 0.5) 50%, transparent 100%);
        transform: translateX(-200%) skewX(-45deg);
        animation: shine 5s infinite;
        z-index: 1;
        pointer-events: none;
      }

      #apricot div.popup>button {
        color: #000000 !important;
        font-family: "Barlow", "Roboto", "Helvetica", "Segoe UI", "Arial", sans-serif;
        font-size: 1.0rem !important;
        font-weight: bold !important;
        line-height: 2.0rem !important;
      }

      #apricot div.popup>button:not(:last-child) {
        border-bottom: 1px solid hsl(0, 0%, 93%) !important;
      }

      #apricot span.stats {
        margin: 0;
        padding: 1px;
        background-color: #000000;
        font-family: "Barlow", "M PLUS Rounded 1c", sans-serif;
        font-size: 0.75rem;
        font-weight: bold;
        line-height: 0.75rem;
        height: 0.75rem;
        vertical-align: middle;
        color: #ffffff;
        opacity: 0;
        transition: .5s;
      }

      #apricot span.stats:hover {
        opacity: 1;
        transition: .5s;
      }

      @keyframes fade {
        from {
          opacity: 0;
        }

        to {
          opacity: 1;
        }
      }

      @keyframes mask{
        to {
          background-size: 150% 100%;
        }
      }

      @keyframes reveal {
        to {
          background-position: calc(-200% + 1px) 0, 0 0;
        }
      }

      @keyframes frame {
        0% {
          margin-left: 0%;
        }

        100% {
          margin-left: -400%;
        }
      }

      @keyframes loading {
          0% {
              transform: rotate(0deg);
          }

          100% {
              transform: rotate(360deg);
          }
      }

      @keyframes processing {
          0% {
              opacity: 1;
          }

          50% {
            opacity: 0.5;
          }

          100% {
            opacity: 1;
          }
      }

      @keyframes shine {
        0% {
          transform: translateX(-200%) skewX(-45deg);
        }
        100% {
          transform: translateX(200%) skewX(-45deg);
        }
      }

      @media screen and (min-width: 769px) and (min-height: 769px) {
        html {
          background: var(--background-color);
        }

        body>.wrap {
          padding: 16px;
          transition: 0.5s;
        }

        body>.warp>.frame {
          border-radius: 4px;
          transition: 0.5s;
        }

        body>.overlay {
          padding: 32px;
          mask-image: linear-gradient(to bottom, transparent, transparent 16px, black 32px, black calc(100% - 32px), transparent calc(100% - 16px), transparent), linear-gradient(black, black);
          mask-size: calc(100% - 32px) 100%, 32px 100%;
          transition: 0.5s;
        }

        .overlay>.wrap>.content {
          box-sizing: border-box;
          margin: 0;
          padding: 0px 0px 32px 0px;
          transition: padding 0.5s;
        }

        .overlay>.wrap>.content .icon.is-animatable {
          right: 32px;
        }

        div.sidebar {
          left: 16px;
          height: calc(100% - 64px);
          transition: 0.5s;
        }
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <div class="frame">
      </div>
    </div>
    <div class="overlay">
      <div class="sidebar">
        <div class="level">
          <div class="level-item">
            <div class="level">
              <div class="level-item">
                <div class="rotation-outer">
                  <div class="rotation-inner">
                    <div class="rotate">
                      <a class="button" href="https://milchchan.com/" title="milchchan.com">
                        <div class="stack">
                          <div class="wrap has-text-weight-bold is-uppercase">
                            <div class="clip">
                              <div class="scrollable">
                                <div>milchchan.com</div>
                                <div>milchchan.com</div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </a>
                    </div>
                  </div>
                </div>
              </div>
              <div class="level-item">
                <div class="separator">
                  <hr>
                </div>
              </div>
              <div class="level-item">
                <div class="rotation-outer">
                <div class="rotation-inner">
                    <div class="rotate">
                    <button class="button is-selected" type="button" onclick="select(event);" data-type="milch">
                        <div class="stack">
                        <div class="wrap has-text-weight-bold is-uppercase">
                            <div class="clip">
                            <div class="scrollable">
                                <div>Milch</div>
                                <div>Milch</div>
                            </div>
                            </div>
                        </div>
                        </div>
                    </button>
                    </div>
                </div>
                </div>
              </div>
              <div class="level-item">
                <div class="separator">
                  <hr>
                </div>
              </div>
              <div class="level-item">
                <div class="rotation-outer">
                <div class="rotation-inner">
                    <div class="rotate">
                    <button class="button" type="button" onclick="select(event);" data-type="merku">
                        <div class="stack">
                        <div class="wrap has-text-weight-bold is-uppercase">
                            <div class="clip">
                            <div class="scrollable">
                                <div>Merku</div>
                                <div>Merku</div>
                            </div>
                            </div>
                        </div>
                        </div>
                    </button>
                    </div>
                </div>
                </div>
              </div>
              <div class="level-item">
                <div class="separator">
                  <hr>
                </div>
              </div>
              <div class="level-item">
                <div class="rotation-outer">
                <div class="rotation-inner">
                    <div class="rotate">
                    <button class="button" type="button" onclick="select(event);" data-type="story">
                        <div class="stack">
                        <div class="wrap has-text-weight-bold is-uppercase">
                            <div class="clip">
                            <div class="scrollable">
                                <div>Story</div>
                                <div>Story</div>
                            </div>
                            </div>
                        </div>
                        </div>
                    </button>
                    </div>
                </div>
                </div>
              </div>
              <div class="level-item is-hidden">
                <div class="rotation-outer">
                <div class="rotation-inner">
                    <div class="rotate">
                    <button class="button is-animatable" type="button" title="Record" onclick="record(event);">
                        <span class="icon">
                          <i class="fa-solid fa-microphone"></i>
                        </span>
                    </button>
                    </div>
                </div>
                </div>
              </div>
              <div class="level-item">
                <div class="rotation-outer">
                <div class="rotation-inner">
                    <div class="rotate">
                    <button class="button is-animatable" type="button" title="Reload" onclick="reload(event);">
                        <span class="icon is-rotatable">
                          <i class="fa-solid fa-arrows-rotate"></i>
                        </span>
                    </button>
                    </div>
                </div>
                </div>
              </div>
              <div class="level-item">
                <div class="rotation-outer">
                <div class="rotation-inner">
                    <div class="rotate">
                    <button class="button is-animatable" type="button" title="Continue" data-prompt="続けてください。" onclick="more(event);">
                        <span class="icon">
                          <i class="fa-solid fa-plus"></i>
                        </span>
                    </button>
                    </div>
                </div>
                </div>
              </div>
            </div>
          </div>
          <div class="level-item">
            <div class="level">
              <div class="level-item">
                <div class="rotation-outer">
                  <div class="rotation-inner">
                    <div class="rotate">
                      <a class="button" href="/privacy" title="Privacy Policy">
                        <div class="wrap has-text-weight-bold is-uppercase">
                          <div class="clip">
                            <div class="scrollable">
                              <div>Privacy</div>
                              <div>Privacy</div>
                            </div>
                          </div>
                        </div>
                      </a>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="content is-selected" data-type="milch" data-prompt="自己紹介してください。お名前、所属、メルクちゃんのことを教えてください。" data-language="ja">
          <div class="icon is-animatable">
            <a class="button" href="https://clock.milchchan.com/" title="Clock">
              <figure>
                <picture>
                  <!--<source srcset="images/PixelatedLuna-Transformed.png 1x, images/PixelatedLuna-Transformed@2x.png 2x, images/PixelatedLuna-Transformed@3x.png 3x" media="(prefers-color-scheme: dark)">-->
                  <img src="images/PixelatedMilch-Transformed.png" srcset="images/PixelatedMilch-Transformed.png 1x, images/PixelatedMilch-Transformed@2x.png 2x, images/PixelatedMilch-Transformed@3x.png 3x" alt="Milch">
                </picture>
              </figure>
            </a>
          </div>
          <div>
            <h1>
              <span class="reveal">Milch</span>
            </h1>
            <h2>
              <span class="reveal has-text-weight-bold">ミルヒちゃん</span>
            </h2>
            <div>
              <div>
                <p>
                  <span class="reveal">天真爛漫で魔法少女のことが好きな小学5年生の女の子。</span>
                </p>
              </div>
              <div>
                <p>
                  <span class="reveal">お友達のメルクちゃんとは仲良し。</span>
                </p>
              </div>
              <div>
                <p>
                  <span class="reveal">魔法少女が好きなことは、メルクちゃんを除いて秘密。</span>
                </p>
              </div>
              <div>
                <p>
                  <span class="reveal">純粋すぎてメルクちゃんの言うことを信じて疑わないので、いつもメルクちゃんの思うがままにされてしまう。</span>
                </p>
              </div>
              <div>
                <p>
                  <span class="reveal">メルクちゃんに魔法少女の衣装を着せられて、メルクちゃんといっしょに魔法少女をすることになった。</span>
                </p>
              </div>
            </div>
          </div>
        </div>
        <div class="content" data-type="merku" data-prompt="自己紹介してください。お名前、所属、ミルヒちゃんのことを教えてください。" data-language="ja">
          <div class="icon is-animatable">
            <a class="button" href="https://clock.milchchan.com/" title="Clock">
              <figure>
                <picture>
                  <img src="images/PixelatedMilch-Transformed.png" srcset="images/PixelatedMerku-Transformed.png 1x, images/PixelatedMerku-Transformed@2x.png 2x, images/PixelatedMerku-Transformed@3x.png 3x" alt="Merku">
                </picture>
              </figure>
            </a>
          </div>
          <div>
            <h1>
              <span class="reveal">Merku</span>
            </h1>
            <h2>
              <span class="reveal has-text-weight-bold">メルクちゃん</span>
            </h2>
            <div>
              <div>
                <p>
                  <span class="reveal">おっとりしていてお金持ちの小学5年生の女の子。</span>
                </p>
              </div>
              <div>
                <p>
                  <span class="reveal">お友達のミルヒちゃんのことが大好きすぎて、ミルヒちゃんのためなら何でもする。</span>
                </p>
              </div>
              <div>
                <p>
                  <span class="reveal">時々、ミルヒちゃんへの溢れる気持ちを抑えきれず暴走しちゃいがち。</span>
                </p>
              </div>
              <div>
                <p>
                  <span class="reveal">つくった魔法少女の衣装をミルヒちゃんに着せてあげて、いっしょに魔法少女を始めた。</span>
                </p>
              </div>
              <div>
                <p>
                  <span class="reveal">趣味で魔法少女の薄い本を描いているが、ミルヒちゃんには秘密。</span>
                </p>
              </div>
            </div>
          </div>
        </div>
        <div class="content" data-type="story" data-prompts='["今日のメルクちゃんの日記で綴るミルヒちゃんとメルクちゃんの日常の短編小説を書いてください。今日の日付も日記に記載してください。", "プロットから短編小説を書いてください。", "同人誌即売会をテーマにした百合百合なメルクちゃん視点の短編小説を書いてください。"]'>
          <div class="icon is-animatable">
            <a class="button" href="https://clock.milchchan.com/" title="Clock">
              <figure>
                <picture>
                  <source srcset="images/PixelatedMerku-Transformed.png 1x, images/PixelatedMerku-Transformed@2x.png 2x, images/PixelatedMerku-Transformed@3x.png 3x" media="(prefers-color-scheme: dark)">
                  <img src="images/PixelatedMilch-Transformed.png" srcset="images/PixelatedMilch-Transformed.png 1x, images/PixelatedMilch-Transformed@2x.png 2x, images/PixelatedMilch-Transformed@3x.png 3x" alt="Milch">
                </picture>
              </figure>
            </a>
          </div>
          <div>
            <h1>
              <span class="reveal">Story</span>
            </h1>
            <h2>
              <span class="reveal has-text-weight-bold">ストーリー</span>
            </h2>
            <div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script type="importmap">
      {
          "imports": {
          "apricot": "./js/apricot.mjs"
          }
      }
    </script>
    <script type="module">
      import { Agent, Animation } from "apricot";
      const hash = decodeURIComponent(window.location.hash.substring(1));
      const temperature = new URL(window.location.href).searchParams.get("temperature") ?? 1.0;
      const touches = [];
      let speechRecognition = null;
      let isRecording = false;
      let isPlaying = false;
      let audioContext = null;
      let sampleRate = 32000;
      const agent = new Agent(0.5);
      let modifiers = [];
      let words = [];

      agent.tools = [{
        "type": "mcp",
        "server_label": "milchchan-mcp",
        "server_url": "https://milchchan.com/api/mcp",
        "require_approval": "never"
      }];

      window.SpeechRecognition = window.SpeechRecognition || webkitSpeechRecognition;

      function random(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);

        return Math.floor(Math.random() * (max - min)) + min;
      }

      async function resize(blob, length) {
        return await new Promise(async (resolve, reject) => {
          const reader = new FileReader();

          reader.onload = () => {
            const image = new Image();

            image.onload = () => {
              const canvas = document.createElement("canvas");

              if (image.width>image.height) {
                if (image.width>length) {
                  canvas.width = length;
                  canvas.height = Math.floor(
                    (length / image.width) * image.height
                  );
                } else {
                  canvas.width = image.width;
                  canvas.height = image.height;
                }
              } else if (image.height>length) {
                canvas.width = Math.floor(
                  (length / image.height) * image.width
                );
                canvas.height = length;
              } else {
                canvas.width = image.width;
                canvas.height = image.height;
              }

              const ctx = canvas.getContext("2d");

              ctx.imageSmoothingEnabled = true;
              ctx.imageSmoothingQuality = "high";
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
              ctx.canvas.toBlob(async (blob) => {
                resolve(blob);

                ctx.canvas.width = ctx.canvas.height = 0;
              }, "image/png");
            };
            image.onerror = (error) => {
              reject(error);
            };
            image.crossOrigin = "anonymous";
            image.src = reader.result;
          };
          reader.onerror = () => {
            reject(reader.error);
          };
          reader.readAsDataURL(blob);
        });
      }

      function shake(element, isRotate = false) {
        if (isRotate) {
          element.animate([
            { transform: "translate3d(0, 5px, 0)" },
            { transform: "translate3d(0, 0, 0)" },
            { transform: "translate3d(0, -5px, 0)" },
            { transform: "translate3d(0, 4px, 0)" },
            { transform: "translate3d(0, 0, 0)" },
            { transform: "translate3d(0, -4px, 0)" },
            { transform: "translate3d(0, 3px, 0)" },
            { transform: "translate3d(0, 0, 0)" },
            { transform: "translate3d(0, -3px, 0)" },
            { transform: "translate3d(0, 2px, 0)" },
            { transform: "translate3d(0, 0, 0)" },
            { transform: "translate3d(0, -2px, 0)" },
            { transform: "translate3d(0, 1px, 0)" },
            { transform: "translate3d(0, 0, 0)" },
            { transform: "translate3d(0, -1px, 0)" }],
            { fill: "forwards", duration: 500, iterations: 1 }).onfinish = () => {
              element.style.transform = "translate3d(0, 0, 0)";
            };
        } else {
          element.animate([
            { transform: "translate3d(5px, 0, 0)" },
            { transform: "translate3d(0, 0, 0)" },
            { transform: "translate3d(-5px, 0, 0)" },
            { transform: "translate3d(4px, 0, 0)" },
            { transform: "translate3d(0, 0, 0)" },
            { transform: "translate3d(-4px, 0, 0)" },
            { transform: "translate3d(3px, 0, 0)" },
            { transform: "translate3d(0, 0, 0)" },
            { transform: "translate3d(-3px, 0, 0)" },
            { transform: "translate3d(2px, 0, 0)" },
            { transform: "translate3d(0, 0, 0)" },
            { transform: "translate3d(-2px, 0, 0)" },
            { transform: "translate3d(1px, 0, 0)" },
            { transform: "translate3d(0, 0, 0)" },
            { transform: "translate3d(-1px, 0, 0)" }],
            { fill: "forwards", duration: 500, iterations: 1 }).onfinish = () => {
              element.style.transform = "translate3d(0, 0, 0)";
            };
        }
      }

      async function change(url) {
        const background = document.createElement("div");
        const image = document.createElement("div");

        background.className = "background";
        background.style.opacity = 0;
        background.style.transform = "scale3d(1.1, 1.1, 1.1)";

        document.body.querySelector(".wrap>.frame").prepend(background);
        background.appendChild(image);

        try {
          const response = await fetch(url);

          if (response.ok) {
            image.style.backgroundImage = `url('${await new Promise(async (resolve, reject) => {
              const reader = new FileReader();

              reader.onload = () => {
                resolve(reader.result);
              };
              reader.onerror = () => {
                reject(reader.error);
              };
              reader.readAsDataURL(await resize(await response.blob(), Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio));
            })}')`;
          }
        } catch (error) {
          console.error(error);
        }

        for (const element of document.body.querySelectorAll(".wrap>.frame>.background")) {
          if (element !== background) {
            element.animate([
                {
                opacity: 0,
                transform: "scale3d(1.1, 1.1, 1.1)",
                },
            ], {
                delay: 0,
                fill: "forwards",
                duration: 500,
                iterations: 1,
                easing: "ease-in"
            }).onfinish = () => {
                element.remove();
            };
          }
        }

        background.animate([
          {
            opacity: 1,
            transform: "scale3d(1.0, 1.0, 1.0)",
          },
        ], {
          delay: 0,
          fill: "forwards",
          duration: 500,
          iterations: 1,
          easing: "ease-out"
        }).onfinish = () => {
          background.style.opacity = 1;
          background.style.transform = "scale3d(1.0, 1.0, 1.0)";
        };
      }

      async function synthesize(source, prompt, input, language, temperature = 1.0) {
        const response1 = await fetch(encodeURI(prompt));

        if (response1.ok) {
          const formData = new FormData();

          formData.append("file", await response1.blob(), "prompt.wav");
          formData.append("data", JSON.stringify({ input: input, language: language, temperature: temperature }));

          const response2 = await fetch("https://milchchan.com/api/generate", {
            mode: "cors",
            method: "POST",
            body: formData
          });

          if (response2.ok) {
            const blob = await response2.blob();
            const [arrayBuffer, sr] = await new Promise(async (resolve, reject) => {
              const reader = new FileReader();

              reader.onload = () => {
                const arrayBuffer = reader.result;
                const view = new DataView(arrayBuffer);
                const sampleRate = view.getUint32(24, true);
                
                resolve([arrayBuffer, sampleRate]);
              };
              reader.onerror = () => {
                reject(reader.error);
              };
              reader.readAsArrayBuffer(blob);
            });

            const buffer = await audioContext.decodeAudioData(arrayBuffer);

            sampleRate = sr;
            
            source.buffer = buffer;
            source.onended = () => {
              source.disconnect();
              audioContext.close();
              audioContext = null;
              isPlaying = false;
            };
            source.start(0);
            isPlaying = true;
          } else {
            throw new Error(response2.statusText);
          }

        }
      }

      function more(choice = null) {
        const recordButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(8) .button");
        const reloadButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(9) .button");
        const moreButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:last-child .button");
        
        if (recordButton !== null && reloadButton !== null && moreButton !== null) {
          for (const element1 of document.body.querySelectorAll("div.overlay>.wrap>.content")) {
            if (element1.classList.contains("is-selected")) {
              const element2 = element1.querySelector(":scope>div:last-of-type>div:last-of-type");

              recordButton.disabled = true;
              reloadButton.disabled = true;
              reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) + 1;
              moreButton.disabled = true;

              if (element1.dataset.type === "milch") {
                agent.isLoading = true;
              }

              new Promise(async (resolve, reject) => {
                let prompt = null;

                if ("prompts" in element1.dataset) {
                  let prompts;

                  try {
                    prompts = await new Promise(async (resolve, reject) => {
                      try {
                        resolve(JSON.parse(element1.dataset.prompts));
                      } catch (error) {
                        reject(error);
                      }
                    });
                  } catch (error) {
                    reject(error);

                    return;
                  }

                  if (prompts.length > 0) {
                    prompt = prompts[~~random(0, prompts.length)];
                  }
                } else if ("prompt" in element1.dataset) {
                  prompt = element1.dataset.prompt;
                }

                if (prompt === null) {
                  resolve(null);
                } else {
                  try {
                    const response1 = await fetch(encodeURI(`${element1.dataset.type}.txt`));

                    if (response1.ok) {
                      const messages = [{role: "system", content: `今日は${new Date().toLocaleDateString()}です。\n\n${await response1.text()}`}, {role: "user", content: prompt}];
                      
                      for (const element3 of element2.querySelectorAll(":scope>div>p.is-generated>span")) {
                        if ("prompt" in element3.dataset) {
                          messages.push({role: "user", content: element3.dataset.prompt});
                        }

                        if ("output" in element3.dataset) {
                          messages.push({role: "assistant", content: element3.dataset.output});
                        }
                      }

                      messages.push({role: "user", content: choice === null ? moreButton.dataset.prompt : choice});

                      const response2 = await fetch("https://milchchan.com/api/generate", {
                        mode: "cors",
                        method: "POST",
                        headers: {
                          "Content-Type": "application/json"
                        },
                        body: JSON.stringify({temperature: temperature, messages: messages})
                      });

                      if (response2.ok) {
                        resolve(agent.parse(await response2.json()));
                      } else {
                        throw new Error(response2.statusText);
                      }
                    } else {
                      throw new Error(response1.statusText);
                    }
                  } catch (error) {
                    reject(error);
                  }
                }
              }).then((data) => {
                if (data !== null && data[0] !== null) {
                  const [message, likability, state, choices, raw] = data;
                  const div = element1.querySelector(":scope>div>div:last-of-type");

                  if (div !== null) {
                    const italicRequired = div.querySelector(":scope>div>p:not(.is-generated)") !== null;

                    for (const content of message.split("\n")) {
                      if (content.length > 0) {
                        const wrap = document.createElement("div");
                        const p = document.createElement("p");
                        const span = document.createElement("span");

                        p.classList.add("is-generated");

                        if ("language" in element1.dataset) {
                          wrap.classList.add("is-playable");

                          p.onclick = async () => {
                            if (!p.classList.contains("is-loading") && !isPlaying) {
                              p.classList.add("is-loading");
                              
                              audioContext = audioContext ?? new window.AudioContext({ sampleRate: sampleRate });
                                    
                              const source = audioContext.createBufferSource();
                                    
                              source.connect(audioContext.destination);

                              try {
                                await synthesize(source, `sounds/${element1.dataset.type}.${element1.dataset.language}.wav`, content, element1.dataset.language, temperature);
                              } catch (error) {
                                shake(p);

                                console.error(error);
                              }

                              p.classList.remove("is-loading");
                            }
                          };
                        }

                        span.classList.add("reveal");
                        span.dataset["prompt"] = moreButton.dataset.prompt;
                        span.dataset["output"] = raw;
                        
                        if (italicRequired) {
                          span.classList.add("is-italic");
                        }
                        
                        span.textContent = content;

                        p.appendChild(span);
                        wrap.appendChild(p);
                        div.appendChild(wrap);
                      }
                    }
                  }

                  if (agent.isLoading) {
                    agent.isLoading = false;

                    if (state !== null) {
                      const animations = agent.character.animations.filter(x => x.name === "Emote" && new RegExp(x.state).test(data[3]));
                      let animation;

                      if (animations.length > 0) {
                        animation = animations[~~random(0, animations.length)];
                      } else {
                        const animations = agent.character.animations.filter(x => x.name === "Emote" && x.state === null);

                        animation = animations[~~random(0, animations.length)];
                      }

                      agent.speak(message, new Animation(animation.name, animation.state, animation.repeats, animation.frames));
                      
                      if (likability !== null) {
                        agent.likability = {a: agent.likability.a, b: likability};
                      }

                      if (choices !== null) {
                        agent._choices.splice(0);
                        agent._choices.push(...choices);
                        agent.ongenerated();
                      }
                    }
                  }
                } else if (agent.isLoading) {
                  agent.isLoading = false;
                }

                reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) - 1;

                if (reloadButton.dataset["counter"] === "0") {
                  recordButton.disabled = false;
                  reloadButton.disabled = false;
                  moreButton.disabled = false;
                }
              }).catch((error) => {
                if (agent.isLoading) {
                  agent.isLoading = false;
                }

                reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) - 1;

                if (reloadButton.dataset["counter"] === "0") {
                  recordButton.disabled = false;
                  reloadButton.disabled = false;
                  moreButton.disabled = false;
                }

                shake(moreButton, true);

                console.error(error);
              });
            }
          }
        }
      }

      agent["_choices"] = [];
      agent.isDebug = true;
      agent.fontFamily = "Barlow";
      agent.onclick = (e) => {
        agent.choices.splice(0);
        agent.choices.push(...agent._choices);

        if (words.length > 0) {
          const word = words[random(0, words.length)];

          if (modifiers.length > 0 && Math.random() < 0.5) {
            const modifier = modifiers[random(0, modifiers.length)];

            if ([...modifier].every(x => /^[\x00-\x7F]*$/.test(x)) && [...word].every(x => /^[\x00-\x7F]*$/.test(x))) {
              agent.choices.unshift(`${modifiers} ${word}`);
            } else {
              agent.choices.unshift(modifiers + word);
            }
          } else {
            agent.choices.unshift(word);
          }
        }
      }
      agent.ongenerated = () => {
        for (const element of document.body.querySelectorAll("[data-apricot-prompt]")) {
          agent.choices.push(element.dataset.prompt);
        }
      }
      agent.onchose = (choice) => {
        more(choice);
      }

      if (hash.length > 0) {
        for (const element of document.body.querySelectorAll("div.sidebar>.level>.level-item button.button")) {
          if(hash === element.dataset.type) {
            if (!element.classList.contains("is-selected")) {
              element.classList.add("is-selected");
            }
          } else if (element.classList.contains("is-selected")) {
            element.classList.remove("is-selected");
          }
        }

        for (const element of document.body.querySelectorAll("div.overlay>.wrap>.content")) {
          if(hash === element.dataset.type) {
            if (!element.classList.contains("is-selected")) {
              element.classList.add("is-selected");
            }
          } else {
            if (element.classList.contains("is-selected")) {
              element.classList.remove("is-selected");
            }

            element.style.display = "none";
            element.style.opacity = 0;
          }
        }
      }

      if ("SpeechRecognition" in window) {
        const element = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(8)");
        
        if (element !== null && element.classList.contains("is-hidden")) {
          element.classList.remove("is-hidden");
        }

        speechRecognition = new window.SpeechRecognition();
        speechRecognition.lang = "ja-JP";
        speechRecognition.onstart = () => {
          const recordButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(8) .button");
          
          if (recordButton !== null && !recordButton.classList.contains("is-recording")) {
            recordButton.classList.add("is-recording");
            recordButton.disabled = false;
          }

          isRecording = true;
        };
        speechRecognition.onresult = (event) => {
          for (const result of event.results) {
            if (result.isFinal) {
              const recordButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(8) .button");
              const reloadButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(9) .button");
              const moreButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:last-child .button");
              
              if (recordButton !== null && reloadButton !== null && moreButton !== null) {
                for (const element1 of document.body.querySelectorAll("div.overlay>.wrap>.content")) {
                  if (element1.classList.contains("is-selected")) {
                    const element2 = element1.querySelector(":scope>div:last-of-type>div:last-of-type");

                    recordButton.disabled = true;
                    reloadButton.disabled = true;
                    reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) + 1;
                    moreButton.disabled = true;

                    if (element1.dataset.type === "milch") {
                      agent.isLoading = true;
                    }

                    new Promise(async (resolve, reject) => {
                      let prompt = null;

                      if ("prompts" in element1.dataset) {
                        let prompts;

                        try {
                          prompts = await new Promise(async (resolve, reject) => {
                            try {
                              resolve(JSON.parse(element1.dataset.prompts));
                            } catch (error) {
                              reject(error);
                            }
                          });
                        } catch (error) {
                          reject(error);

                          return;
                        }

                        if (prompts.length > 0) {
                          prompt = prompts[~~random(0, prompts.length)];
                        }
                      } else if ("prompt" in element1.dataset) {
                        prompt = element1.dataset.prompt;
                      }

                      if (prompt === null) {
                        resolve(null);
                      } else {
                        try {
                          const response1 = await fetch(encodeURI(`${element1.dataset.type}.txt`));

                          if (response1.ok) {
                            const messages = [{role: "system", content: `今日は${new Date().toLocaleDateString()}です。\n\n${await response1.text()}`}, {role: "user", content: prompt}];
                            
                            for (const element3 of element2.querySelectorAll(":scope>div>p.is-generated>span")) {
                              if ("prompt" in element3.dataset) {
                                messages.push({role: "user", content: element3.dataset.prompt});
                              }

                              if ("output" in element3.dataset) {
                                messages.push({role: "assistant", content: element3.dataset.output});
                              }
                            }

                            messages.push({role: "user", content: result[0].transcript});

                            const response2 = await fetch("https://milchchan.com/api/generate", {
                              mode: "cors",
                              method: "POST",
                              headers: {
                                "Content-Type": "application/json"
                              },
                              body: JSON.stringify({temperature: temperature, messages: messages})
                            });

                            if (response2.ok) {
                              resolve(agent.parse(await response2.json()));
                            } else {
                              throw new Error(response2.statusText);
                            }
                          } else {
                            throw new Error(response1.statusText);
                          }
                        } catch (error) {
                          reject(error);
                        }
                      }
                    }).then((data) => {
                      if (data !== null && data[0] !== null) {
                        const [message, likability, state, choices, raw] = data;
                        const div = element1.querySelector(":scope>div>div:last-of-type");

                        if (div !== null) {
                          const italicRequired = div.querySelector(":scope>div>p:not(.is-generated)") !== null;

                          for (const content of message.split("\n")) {
                            if (content.length > 0) {
                              const wrap = document.createElement("div");
                              const p = document.createElement("p");
                              const span = document.createElement("span");

                              p.classList.add("is-generated");

                              if ("language" in element1.dataset) {
                                wrap.classList.add("is-playable");

                                p.onclick = async () => {
                                  if (!p.classList.contains("is-loading") && !isPlaying) {
                                    p.classList.add("is-loading");

                                    audioContext = audioContext ?? new window.AudioContext({ sampleRate: sampleRate });
                                    
                                    const source = audioContext.createBufferSource();

                                    source.connect(audioContext.destination);

                                    try {
                                      await synthesize(source, `sounds/${element1.dataset.type}.${element1.dataset.language}.wav`, content, element1.dataset.language, temperature);
                                    } catch (error) {
                                      shake(p);

                                      console.error(error);
                                    }

                                    p.classList.remove("is-loading");
                                  }
                                };
                              }

                              span.classList.add("reveal");
                              span.dataset["prompt"] = result[0].transcript;
                              span.dataset["output"] = raw;
                              
                              if (italicRequired) {
                                span.classList.add("is-italic");
                              }
                              
                              span.textContent = content;

                              p.appendChild(span);
                              wrap.appendChild(p);
                              div.appendChild(wrap);
                            }
                          }
                        }

                        if (agent.isLoading) {
                          agent.isLoading = false;

                          if (state !== null) {
                            const animations = agent.character.animations.filter(x => x.name === "Emote" && new RegExp(x.state).test(data[3]));
                            let animation;

                            if (animations.length > 0) {
                              animation = animations[~~random(0, animations.length)];
                            } else {
                              const animations = agent.character.animations.filter(x => x.name === "Emote" && x.state === null);

                              animation = animations[~~random(0, animations.length)];
                            }

                            agent.speak(message, new Animation(animation.name, animation.state, animation.repeats, animation.frames));
                            
                            if (likability !== null) {
                              agent.likability = {a: agent.likability.a, b: likability};
                            }

                            if (choices !== null) {
                              agent._choices.splice(0);
                              agent._choices.push(...choices);
                              agent.ongenerated();
                            }
                          }
                        }
                      } else if (agent.isLoading) {
                        agent.isLoading = false;
                      }

                      reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) - 1;

                      if (reloadButton.dataset["counter"] === "0") {
                        recordButton.disabled = false;
                        reloadButton.disabled = false;
                        moreButton.disabled = false;
                      }
                    }).catch((error) => {
                      if (agent.isLoading) {
                        agent.isLoading = false;
                      }

                      reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) - 1;

                      if (reloadButton.dataset["counter"] === "0") {
                        recordButton.disabled = false;
                        reloadButton.disabled = false;
                        moreButton.disabled = false;
                      }

                      shake(moreButton, true);

                      console.error(error);
                    });
                  }
                }
              }

              break;
            }
          }
        };
        speechRecognition.onend = (event) => {
          const recordButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(8) .button");
          
          if (recordButton !== null && recordButton.classList.contains("is-recording")) {
            recordButton.classList.remove("is-recording");
          }

          isRecording = false;
        };
        speechRecognition.onerror = (event) => {
          if (event.error !== "aborted") {
            const recordButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(8) .button");
            
            if (recordButton !== null) {
              shake(recordButton, true);
            }

            console.error(event.error);
          }
        };
      }

      /*for (const element of document.body.querySelectorAll(".overlay>.wrap>.content")) {
        element.addEventListener("mouseenter", async (event) => {
          const image = document.body.querySelector(".wrap>.frame>.background>div");

          if (image !== null && !image.classList.contains("is-touching")) {
            image.classList.add("is-touching");
          }
        });
        element.addEventListener("mouseleave", async (event) => {
          const image = document.body.querySelector(".wrap>.frame>.background>div");

          if (image !== null && image.classList.contains("is-touching")) {
            image.classList.remove("is-touching");
          }
        });
        element.addEventListener("touchstart", async (event) => {
          event.stopPropagation();

          if (touches.length === 0) {
            const image = document.body.querySelector(".wrap>.frame>.background>div");

            if (image !== null && !image.classList.contains("is-touching")) {
              image.classList.add("is-touching");
            }
          }

          for (const touch of event.changedTouches) {
            touches.push(touch.identifier);
          }
        });
        element.addEventListener("touchend", async (event) => {
          event.stopPropagation();

          for (const touch of event.changedTouches) {
            let index = touches.findIndex(x => x === touch.identifier);

            if (index >= 0) {
              touches.splice(index, 1);
            }
          }

          if (touches.length === 0) {
            const image = document.body.querySelector(".wrap>.frame>.background>div");

            if (image !== null && image.classList.contains("is-touching")) {
              image.classList.remove("is-touching");
            }
          }
        });
        element.addEventListener("touchcancel", async (event) => {
          event.stopPropagation();

          for (const touch of event.changedTouches) {
            let index = touches.findIndex(x => x === touch.identifier);

            if (index >= 0) {
              touches.splice(index, 1);
            }
          }

          if (touches.length === 0) {
            const image = document.body.querySelector(".wrap>.frame>.background>div");

            if (image !== null && image.classList.contains("is-touching")) {
              image.classList.remove("is-touching");
            }
          }
        });
      }*/

      window.record = (event) => {
        if (speechRecognition === null) {
          shake(event.currentTarget || event.target, true);
        } else if (isRecording) {
          speechRecognition.stop();
        } else {
          const recordButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(8) .button");
          
          if (recordButton !== null) {
            recordButton.disabled = true;
          }

          speechRecognition.start();
        }
      };
      window.select = (event) => {
        const target = (event.currentTarget || event.target);

        for (const element1 of document.body.querySelectorAll("div.sidebar>.level>.level-item button.button")) {
          if (element1.dataset.type === target.dataset.type) {
            if (!element1.classList.contains("is-selected")) {
              for (const element2 of document.body.querySelectorAll("div.overlay>.wrap>.content")) {
                if (element1.dataset.type === element2.dataset.type && !element2.classList.contains("is-selected")) {
                  if (element2.style.display === "none") {
                    const recordButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(8) .button");
                    const reloadButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(9) .button");
                    const moreButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:last-child .button");
    
                    if (element2.dataset.type === "milch") {
                      agent.dom.classList.add("is-active");
                      agent.dom.style.pointerEvents = "auto";
                    } else {
                      if (agent.dom.classList.contains("is-active")) {
                        agent.dom.classList.remove("is-active");
                      }

                      agent.dom.style.pointerEvents = "none";
                    }

                    element2.classList.add("is-selected");
                    element2.style.display = "block";
                    element2.animate(
                      [
                        {
                          opacity: 1,
                        },
                      ],
                      {
                        delay: 0,
                        fill: "forwards",
                        duration: 500,
                        iterations: 1,
                        easing: "ease-out",
                        composite: "replace",
                      }
                    ).onfinish = (event) => {
                      if (element2.classList.contains("is-selected")) {
                        element2.style.opacity = 1;
                      }
                    };

                    if ("generated" in element2.dataset === false && recordButton !== null && reloadButton !== null && moreButton !== null) {
                      recordButton.disabled = true;
                      reloadButton.disabled = true;
                      reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) + 1;
                      moreButton.disabled = true;

                      element2.dataset["generated"] = false;

                      if (element2.dataset.type === "milch") {
                        agent.isLoading = true;
                      }

                      new Promise(async (resolve, reject) => {
                        let prompt = null;

                        if ("prompts" in element2.dataset) {
                          let prompts;

                          try {
                            prompts = await new Promise(async (resolve, reject) => {
                              try {
                                resolve(JSON.parse(element2.dataset.prompts));
                              } catch (error) {
                                reject(error);
                              }
                            });
                          } catch (error) {
                            reject(error);

                            return;
                          }

                          if (prompts.length > 0) {
                            prompt = prompts[~~random(0, prompts.length)];
                          }
                        } else if ("prompt" in element2.dataset) {
                          prompt = element2.dataset.prompt;
                        }

                        if (prompt === null) {
                          resolve(null);
                        } else {
                          try {
                            const response1 = await fetch(encodeURI(`${element2.dataset.type}.txt`));

                            if (response1.ok) {
                              const response2 = await fetch("https://milchchan.com/api/generate",
                                {
                                  mode: "cors",
                                  method: "POST",
                                  headers: {
                                    "Content-Type": "application/json",
                                  },
                                  body: JSON.stringify({temperature: temperature, messages: [{role: "system", content: `今日は${new Date().toLocaleDateString()}です。\n\n${await response1.text()}`}, {role: "user", content: prompt}]}),
                                }
                              );

                              if (response2.ok) {
                                resolve(agent.parse(await response2.json()));
                              } else {
                                throw new Error(response2.statusText);
                              }
                            } else {
                              throw new Error(response1.statusText);
                            }
                          } catch (error) {
                            reject(error);
                          }
                        }
                      }).then((data) => {
                        if (data !== null && data[0] !== null) {
                          const [message, likability, state, choices, raw] = data;
                          const div = element2.querySelector(":scope>div>div:last-of-type");

                          if (div !== null) {
                            const italicRequired = div.querySelector(":scope>div>p:not(.is-generated)") !== null;

                            for (const content of message.split("\n")) {
                              if (content.length > 0) {
                                const wrap = document.createElement("div");
                                const p = document.createElement("p");
                                const span = document.createElement("span");

                                p.classList.add("is-generated");

                                if ("language" in element2.dataset) {
                                  wrap.classList.add("is-playable");

                                  p.onclick = async () => {
                                    if (!p.classList.contains("is-loading") && !isPlaying) {
                                      p.classList.add("is-loading");

                                      audioContext = audioContext ?? new window.AudioContext({ sampleRate: sampleRate });
                                  
                                      const source = audioContext.createBufferSource();
                                      
                                      source.connect(audioContext.destination);

                                      try {
                                        await synthesize(source, `sounds/${element2.dataset.type}.${element2.dataset.language}.wav`, content, element2.dataset.language, temperature);
                                      } catch (error) {
                                        shake(p);

                                        console.error(error);
                                      }

                                      p.classList.remove("is-loading");
                                    }
                                  };
                                }

                                span.classList.add("reveal");
                                span.dataset["output"] = raw;

                                if (italicRequired) {
                                  span.classList.add("is-italic");
                                }

                                span.textContent = content;

                                p.appendChild(span);
                                wrap.appendChild(p);
                                div.appendChild(wrap);
                              }
                            }
                          }

                          element2.dataset["generated"] = true;

                          if (agent.isLoading) {
                            agent.isLoading = false;

                            if (state !== null) {
                              const animations = agent.character.animations.filter(x => x.name === "Emote" && new RegExp(x.state).test(data[3]));
                              let animation;

                              if (animations.length > 0) {
                                animation = animations[~~random(0, animations.length)];
                              } else {
                                const animations = agent.character.animations.filter(x => x.name === "Emote" && x.state === null);

                                animation = animations[~~random(0, animations.length)];
                              }

                              agent.speak(message, new Animation(animation.name, animation.state, animation.repeats, animation.frames));
                              
                              if (likability !== null) {
                                agent.likability = {a: agent.likability.a, b: likability};
                              }

                              if (choices !== null) {
                                agent._choices.splice(0);
                                agent._choices.push(...choices);
                                agent.ongenerated();
                              }
                            }
                          }
                        } else if (agent.isLoading) {
                          agent.isLoading = false;
                        }

                        reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) - 1;

                        if (reloadButton.dataset["counter"] === "0") {
                          recordButton.disabled = false;
                          reloadButton.disabled = false;
                          moreButton.disabled = false;
                        }
                      }).catch((error) => {
                        if (agent.isLoading) {
                          agent.isLoading = false;
                        }

                        delete element2.dataset["generated"];

                        reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) - 1;

                        if (reloadButton.dataset["counter"] === "0") {
                          recordButton.disabled = false;
                          reloadButton.disabled = false;
                          moreButton.disabled = false;
                        }

                        shake(element1);

                        console.error(error);
                      });
                    }

                    for (const element3 of document.body.querySelectorAll("div.overlay>.wrap>.content")) {
                      if (element1.dataset.type !== element3.dataset.type && element3.classList.contains("is-selected")) {
                        element3.classList.remove("is-selected");
                        element3.animate(
                          [
                            {
                              opacity: 0,
                            },
                          ],
                          {
                            delay: 0,
                            fill: "forwards",
                            duration: 500,
                            iterations: 1,
                            easing: "ease-in",
                            composite: "replace",
                          }
                        ).onfinish = () => {
                          if (!element3.classList.contains("is-selected")) {
                            element3.style.display = "none";
                          }
                        };
                      }
                    }
                  } else {
                    shake(element1);

                    return;
                  }

                  element1.classList.add("is-selected");

                  change(window.getComputedStyle(document.documentElement).getPropertyValue(window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? `--${element1.dataset.type}-dark-background-image` : `--${element1.dataset.type}-light-background-image`));
                }
              }
            }

            for (const element2 of document.body.querySelectorAll("div.sidebar>.level>.level-item button.button")) {
              if (element2.dataset.type !== target.dataset.type && element2.classList.contains("is-selected")) {
                element2.classList.remove("is-selected");
              }
            }
          }
        }
      };
      window.reload = (event) => {
        const recordButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(8) .button");
        const reloadButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(9) .button");
        const moreButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:last-child .button");
        
        if (recordButton !== null && reloadButton !== null && moreButton !== null) {
          for (const element1 of document.body.querySelectorAll("div.overlay>.wrap>.content")) {
            if (element1.classList.contains("is-selected")) {
              const element2 = element1.querySelector(":scope>div:last-of-type");

              if (element2 !== null) {
                recordButton.disabled = true;
                reloadButton.disabled = true;
                reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) + 1;
                moreButton.disabled = true;
              
                element2.animate([
                  {
                    opacity: 0
                  }
                ], {
                    delay: 0,
                    fill: "forwards",
                    duration: 500,
                    iterations: 1,
                    easing: "ease-in",
                    composite: "replace"
                }).onfinish = (event) => {
                  const div = document.createElement("div");
                  
                  for (const element3 of Array.from(element2.children)) {
                    for (const element4 of Array.from(element3.children)) {
                      for (const element5 of Array.from(element4.children)) {
                        if (element5.classList.contains("is-generated")) {
                          element4.remove();
                          
                          break;
                        }
                      }
                    }

                    element3.remove();
                    div.appendChild(element3);
                  }

                  element2.replaceWith(div);
                  element1.dataset["generated"] = false;

                  if (element1.dataset.type === "milch") {
                    agent.isLoading = true;
                  }

                  new Promise(async (resolve, reject) => {
                    let prompt = null;

                    if ("prompts" in element1.dataset) {
                      let prompts;

                      try {
                        prompts = await new Promise(async (resolve, reject) => {
                          try {
                            resolve(JSON.parse(element1.dataset.prompts));
                          } catch (error) {
                            reject(error);
                          }
                        });
                      } catch (error) {
                        reject(error);

                        return;
                      }

                      if (prompts.length > 0) {
                        prompt = prompts[~~random(0, prompts.length)];
                      }
                    } else if ("prompt" in element1.dataset) {
                      prompt = element1.dataset.prompt;
                    }

                    if (prompt === null) {
                      resolve(null);
                    } else {
                      try {
                        const response1 = await fetch(encodeURI(`${element1.dataset.type}.txt`));

                        if (response1.ok) {
                          const response2 = await fetch("https://milchchan.com/api/generate", {
                            mode: "cors",
                            method: "POST",
                            headers: {
                              "Content-Type": "application/json"
                            },
                            body: JSON.stringify({temperature: temperature, messages: [{role: "system", content: `今日は${new Date().toLocaleDateString()}です。\n\n${await response1.text()}`}, {role: "user", content: prompt}]})
                          });

                          if (response2.ok) {
                            resolve(agent.parse(await response2.json()));
                          } else {
                            throw new Error(response2.statusText);
                          }
                        } else {
                          throw new Error(response1.statusText);
                        }
                      } catch (error) {
                        reject(error);
                      }
                    }
                  }).then((data) => {
                    if (data !== null && data[0] !== null) {
                      const [message, likability, state, choices, raw] = data;
                      const last = div.querySelector(":scope>div:last-of-type");

                      if (last !== null) {
                        const italicRequired = last.querySelector(":scope>div>p:not(.is-generated)") !== null;

                        for (const content of message.split("\n")) {
                          if (content.length > 0) {
                            const wrap = document.createElement("div");
                            const p = document.createElement("p");
                            const span = document.createElement("span");

                            p.classList.add("is-generated");

                            if ("language" in element1.dataset) {
                              wrap.classList.add("is-playable");

                              p.onclick = async () => {
                                if (!p.classList.contains("is-loading") && !isPlaying) {
                                  p.classList.add("is-loading");
                                  
                                  audioContext = audioContext ?? new window.AudioContext({ sampleRate: sampleRate });
                                  
                                  const source = audioContext.createBufferSource();
                                  
                                  source.connect(audioContext.destination);

                                  try {
                                    await synthesize(source, `sounds/${element1.dataset.type}.${element1.dataset.language}.wav`, content, element1.dataset.language, temperature);
                                  } catch (error) {
                                    shake(p);

                                    console.error(error);
                                  }

                                  p.classList.remove("is-loading");
                                }
                              };
                            }

                            span.classList.add("reveal");
                            span.dataset["output"] = raw;
                            
                            if (italicRequired) {
                              span.classList.add("is-italic");
                            }

                            span.textContent = content;

                            p.appendChild(span);
                            wrap.appendChild(p);
                            last.appendChild(wrap);
                          }
                        }
                      }

                      element1.dataset["generated"] = true;
                    
                      if (agent.isLoading) {
                        agent.isLoading = false;

                        if (state !== null) {
                          const animations = agent.character.animations.filter(x => x.name === "Emote" && new RegExp(x.state).test(data[3]));
                          let animation;

                          if (animations.length > 0) {
                            animation = animations[~~random(0, animations.length)];
                          } else {
                            const animations = agent.character.animations.filter(x => x.name === "Emote" && x.state === null);

                            animation = animations[~~random(0, animations.length)];
                          }

                          agent.speak(message, new Animation(animation.name, animation.state, animation.repeats, animation.frames));
                          
                          if (likability !== null) {
                            agent.likability = {a: agent.likability.a, b: likability};
                          }

                          if (choices !== null) {
                            agent._choices.splice(0);
                            agent._choices.push(...choices);
                            agent.ongenerated();
                          }
                        }
                      }
                    } else if (agent.isLoading) {
                      agent.isLoading = false;
                    }

                    reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) - 1;

                    if (reloadButton.dataset["counter"] === "0") {
                      recordButton.disabled = false;
                      reloadButton.disabled = false;
                      moreButton.disabled = false;
                    }
                  }).catch((error) => {
                    if (agent.isLoading) {
                      agent.isLoading = false;
                    }

                    delete element1.dataset["generated"];

                    reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) - 1;

                    if (reloadButton.dataset["counter"] === "0") {
                      recordButton.disabled = false;
                      reloadButton.disabled = false;
                      moreButton.disabled = false;
                    }

                    shake(reloadButton, true);

                    console.error(error);
                  });
                };
              }
            }
          }
        }
      };
      window.more = (event) => {
        more();
      };

      window.addEventListener("load", async (event) => {
        document.body.appendChild(await agent.load("milch.json"));
        
        agent.run(() => {
          const animations = agent.character.animations.filter(x => x.name === "Start");
          
          agent.commandQueue.push(animations[~~random(0, animations.length)]);
          agent.commandQueue.push(null);
        });

        for (const element of document.body.querySelectorAll("div.overlay>.wrap>.content")) {
          if (element.classList.contains("is-selected")) {
            const background = document.createElement("div");
            const image = document.createElement("div");

            background.className = "background";
            background.style.opacity = 0;
            background.style.transform = "scale3d(1.1, 1.1, 1.1)";
            
            document.body.querySelector(".wrap>.frame").prepend(background);
            background.appendChild(image);

            if (element.dataset.type === "milch") {
              agent.dom.classList.add("is-active");
              agent.dom.style.pointerEvents = "auto";
            } else {
              if (agent.dom.classList.contains("is-active")) {
                agent.dom.classList.remove("is-active");
              }

              agent.dom.style.pointerEvents = "none";
            }
            
            const recordButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(8) .button");
            const reloadButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:nth-child(9) .button");
            const moreButton = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:last-child .button");
        
            if (recordButton !== null && reloadButton !== null && moreButton !== null) {
              recordButton.disabled = true;
              reloadButton.disabled = true;
              reloadButton.dataset["counter"] = 1;
              moreButton.disabled = true;

              if (element.dataset.type === "milch") {
                agent.isLoading = true;
              }

              new Promise(async (resolve, reject) => {
                try {
                    const response = await fetch(window.getComputedStyle(document.documentElement).getPropertyValue(window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? `--${element.dataset.type}-dark-background-image` : `--${element.dataset.type}-light-background-image`));

                    if (response.ok) {
                        image.style.backgroundImage = `url('${await new Promise(async (resolve, reject) => {
                            const reader = new FileReader();

                            reader.onload = () => {
                                resolve(reader.result);
                            };
                            reader.onerror = () => {
                                reject(reader.error);
                            };
                            reader.readAsDataURL(await resize(await response.blob(), Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio));
                        })}')`;
                    }
                } catch (error) {
                    console.error(error);
                }
                
                background.animate([
                  {
                    opacity: 1,
                    transform: "scale3d(1.0, 1.0, 1.0)",
                  },
                ], {
                    delay: 0,
                    fill: "forwards",
                    duration: 500,
                    iterations: 1,
                    easing: "ease-out"
                }).onfinish = () => {
                    background.style.opacity = 1;
                    background.style.transform = "scale3d(1.0, 1.0, 1.0)";
                };

                element.dataset["generated"] = false;

                let prompt = null;

                if ("prompts" in element.dataset) {
                  let prompts;

                  try {
                    prompts = await new Promise(async (resolve, reject) => {
                      try {
                        resolve(JSON.parse(element.dataset.prompts));
                      } catch (error) {
                        reject(error);
                      }
                    });
                  } catch (error) {
                    reject(error);

                    return;
                  }

                  if (prompts.length > 0) {
                    prompt = prompts[~~random(0, prompts.length)];
                  }
                } else if ("prompt" in element.dataset) {
                  prompt = element.dataset.prompt;
                }

                if (prompt === null) {
                  resolve(null);
                } else {
                  try {
                    const response1 = await fetch(encodeURI(`${element.dataset.type}.txt`));

                    if (response1.ok) {
                      const response2 = await fetch("https://milchchan.com/api/generate", {
                        mode: "cors",
                        method: "POST",
                        headers: {
                          "Content-Type": "application/json"
                        },
                        body: JSON.stringify({temperature: temperature, messages: [{role: "system", content: `今日は${new Date().toLocaleDateString()}です。\n\n${await response1.text()}`}, {role: "user", content: prompt}]})
                      });

                      if (response2.ok) {
                        resolve(agent.parse(await response2.json()));
                      } else {
                        throw new Error(response2.statusText);
                      }
                    } else {
                      throw new Error(response1.statusText);
                    }
                  } catch (error) {
                    reject(error);
                  }
                }
              }).then((data) => {
                if (data !== null && data[0] !== null) {
                  const [message, likability, state, choices, raw] = data;
                  const div = element.querySelector(":scope>div>div:last-of-type");

                  if (div !== null) {
                    const italicRequired = div.querySelector(":scope>div>p:not(.is-generated)") !== null;

                    for (const content of message.split("\n")) {
                      if (content.length > 0) {
                        const wrap = document.createElement("div");
                        const p = document.createElement("p");
                        const span = document.createElement("span");

                        p.classList.add("is-generated");
                        
                        if ("language" in element.dataset) {
                          wrap.classList.add("is-playable");

                          p.onclick = async () => {
                            if (!p.classList.contains("is-loading") && !isPlaying) {
                              p.classList.add("is-loading");
                              
                              audioContext = audioContext ?? new window.AudioContext({ sampleRate: sampleRate });
                              
                              const source = audioContext.createBufferSource();
                              
                              source.connect(audioContext.destination);

                              try {
                                await synthesize(source, `sounds/${element.dataset.type}.${element.dataset.language}.wav`, content, element.dataset.language, temperature);
                              } catch (error) {
                                shake(p);
                                
                                console.error(error);
                              }

                              p.classList.remove("is-loading");
                            }
                          };
                        }
                        
                        span.classList.add("reveal");
                        span.dataset["output"] = raw;

                        if (italicRequired) {
                          span.classList.add("is-italic");
                        }

                        span.textContent = content;

                        p.appendChild(span);
                        wrap.appendChild(p);
                        div.appendChild(wrap);
                      }
                    }
                  }

                  element.dataset["generated"] = true;

                  if (agent.isLoading) {
                    agent.isLoading = false;
                    
                    if (state !== null) {
                      const animations = agent.character.animations.filter(x => x.name === "Emote" && new RegExp(x.state).test(data[3]));
                      let animation;

                      if (animations.length > 0) {
                        animation = animations[~~random(0, animations.length)];
                      } else {
                        const animations = agent.character.animations.filter(x => x.name === "Emote" && x.state === null);

                        animation = animations[~~random(0, animations.length)];
                      }

                      agent.speak(message, new Animation(animation.name, animation.state, animation.repeats, animation.frames));
                      
                      if (likability !== null) {
                        agent.likability = {a: agent.likability.a, b: likability};
                      }

                      if (choices !== null) {
                        agent._choices.splice(0);
                        agent._choices.push(...choices);
                        agent.ongenerated();
                      }
                    }
                  }
                } else if (agent.isLoading) {
                  agent.isLoading = false;
                }

                reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) - 1;

                if (reloadButton.dataset["counter"] === "0") {
                  recordButton.disabled = false;
                  reloadButton.disabled = false;
                  moreButton.disabled = false;
                }
              }).catch((error) => {
                if (agent.isLoading) {
                  agent.isLoading = false;
                }

                delete element.dataset["generated"];

                reloadButton.dataset["counter"] = parseInt(reloadButton.dataset["counter"]) - 1;

                if (reloadButton.dataset["counter"] === "0") {
                  recordButton.disabled = false;
                  reloadButton.disabled = false;
                  moreButton.disabled = false;
                }

                shake(reloadButton, true);

                console.error(error);
              });
            }
          } else {
            element.style.display = "none";
            element.style.opacity = 0;
          }
        }
      
        try {
          const response = await fetch(encodeURI("https://milchchan.com/api/likes?language=ja"), {
            mode: "cors",
            method: "GET",
            headers: {
              "Content-Type": "application/x-www-form-urlencoded"
            }
          });
      
          if (response.ok) {
            for (const like of await response.json()) {
              if ("attributes" in like) {
                let index = 0;
  
                while (index < like.content.length) {
                  let maxEnd = index;
                  let boundaryIndex = index;
                  
                  for (const attribute of like.attributes) {
                    if (attribute.start === index && attribute.end > maxEnd) {
                      boundaryIndex = maxEnd;
                      maxEnd = attribute.end;
                    }
                  }

                  if (index !== maxEnd) {
                    if (boundaryIndex === index) {
                      const word = like.content.substring(index, maxEnd);

                      if (!words.includes(word)) {
                        words.push(word);
                      }
                    } else {
                      const modifier = like.content.substring(index, boundaryIndex).trim();
                      const word = like.content.substring(boundaryIndex, maxEnd);

                      if (!modifiers.includes(modifier)) {
                        modifiers.push(modifier);
                      }

                      if (!words.includes(word)) {
                        words.push(word);
                      }
                    }
                  
                    index = maxEnd;

                    continue;
                  }

                  index++;
                }
              }
            }
          }
        } catch (error) {
          console.error(error);
        }
      });
      window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (e) => {
        for (const element of document.body.querySelectorAll("div.overlay>.wrap>.content")) {
          if (element.classList.contains("is-selected")) {
            change(window.getComputedStyle(document.documentElement).getPropertyValue(e.matches ? `--${element.dataset.type}-dark-background-image` : `--${element.dataset.type}-light-background-image`));
          }
        }
      });
    </script>
  </body>
</html>
