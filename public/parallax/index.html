<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />    
<title>PARALLAX</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Barlow:wght@400;700&display=swap" rel="stylesheet" />
<script src="https://kit.fontawesome.com/922939073a.js" crossorigin="anonymous"></script>
<style>
  :root {
    --background-color: rgb(255 255 255 / 1);
    --foreground-color: #000000;
  }

  @media (prefers-color-scheme: dark) {
      :root {
          --background-color: rgb(0 0 0 / 1);
          --foreground-color: #ffffff;
      }
  }
  
  html {
    touch-action: none;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100vh;
    height: 100dvh;
    overflow-x: hidden;
    overflow-y: auto;
    scroll-behavior: smooth;
    background: #ffffff;
    overscroll-behavior-x: none;
    overscroll-behavior-y: none;
  }

  body {
    position: relative;
    margin: 0;
    padding: 0;
    width: 100%;
    min-height: 100vh;
    min-height: -webkit-fill-available;
    min-height: 100dvh;
    overflow: hidden;
    background: transparent;
    font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  }

  #app {
    position: absolute;
    display: flex;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    flex-direction: row;
    align-items: flex-start;
    justify-content: flex-start;
  }

  .container {
    position: relative;
    margin: 0;
    padding: 0;
    width: 100%;
    max-width: 100% !important;
    height: 100%;
    animation: fade .5s ease-out forwards;
  }

  .top {
    -webkit-user-select: none;
    user-select: none;
    position: absolute;
    top: 16px;
    left: 50%;
    padding: max(env(safe-area-inset-top, 0px), env(safe-area-inset-bottom, 0px)) max(env(safe-area-inset-right, 0px), env(safe-area-inset-left, 0px));
    transform: translate(-50%, 0%);
    width: fit-content;
    height: fit-content;
  }

  .bottom {
    -webkit-user-select: none;
    user-select: none;
    position: absolute;
    bottom: 16px;
    left: 50%;
    padding: max(env(safe-area-inset-top, 0px), env(safe-area-inset-bottom, 0px)) max(env(safe-area-inset-right, 0px), env(safe-area-inset-left, 0px));
    transform: translate(-50%, 0%);
    width: fit-content;
    height: fit-content;
  }

  .bottom>.level {
    display: flex;
    margin: -8px;
    padding: 0;
  }

  .bottom>.level>.level-item {
    margin: 0;
    padding: 8px;
  }

  .button {
    margin: 0px;
    border: 0px none transparent !important;
    padding: 16px 32px 16px 32px;
    background-color: var(--background-color);
    background-clip: padding-box !important;
    height: initial;
    backface-visibility: hidden;
    opacity: 1;
    cursor: pointer;
    box-shadow: 0 .5em 1em -.125em #0a0a0a1a, 0 0 0 1px #0a0a0a05 !important;
    transition: .5s;
  }

  .button.is-primary {
    background-color: #3cffd0;
  }

  .button .icon {
    display: flex;
    margin: 0;
    align-items: center;
    justify-content: center;
    color: var(--foreground-color);
    opacity: 1;
    transition: .5s;
    backface-visibility: hidden;
    font-size: 1.0rem;
    width: 16px;
    height: 16px;
    transition: .5s;
  }

  .button.is-primary .icon {
    color: #000000 !important;
  }

  .button:hover .icon {
    opacity: 0.5;
    transition: .5s;
  }

  .button:disabled .icon {
    opacity: 0.5 !important;
    transition: .5s;
  }

  .button .icon.is-hidden {
    opacity: 0 !important;
    transition: .5s;
  }

  .button.is-circle {
    display: flex;
    margin: 0px;
    border-radius: 290486px !important;
    padding: 16px !important;
    align-items: center;
    justify-content: center;
    aspect-ratio: 1;
  }

  .button.is-hidden {
    pointer-events: none;
    opacity: 0;
    transition: .5s;
  }

  .button .stack {
    position: relative;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: flex-start;
  }

  .button .stack>.icon:not(:first-child) {
    position: absolute;
  }

  label.button>input {
    pointer-events: none;
    left: 0;
    top: 0;
    opacity: 0;
    outline: none;
    position: absolute;
    width: 100%;
    height: 100%;
  }

  label.button>input+.icon {
    display: flex;
    margin: 0;
    align-items: center;
    justify-content: center;
    color: #000000;
    opacity: 1;
    transition: .5s;
    backface-visibility: hidden;
    font-size: 1.0rem;
    width: 16px;
    height: 16px;
  }

  label.button>input:disabled+.icon {
    opacity: 0.5 !important;
    transition: .5s;
  }

  .progress {
    pointer-events: none;
    z-index: 1;
    position: absolute;
    margin: 0 !important;
    border: 0px solid transparent;
    border-radius: 0px;
    padding: 0;
    width: 100%;
    height: fit-content;
    top: 0;
    left: 0;
    overflow: hidden;
    backface-visibility: hidden;
    background: transparent;
    touch-action: none;
  }

  .progress>.bar {
    pointer-events: none;
    z-index: 1;
    position: relative;
    top: 0;
    left: 0;
    margin: 0;
    padding: 0;
    border: 0px solid transparent;
    border-radius: 0px;
    width: 100%;
    height: 4px;
    transform: translate3d(0, 0%, 0);
    overflow: hidden;
    background: url('/images/Stripes.png') 0 0 repeat;
    background-color: #5200ff;
    background-size: 24px 24px;
    animation: progress 1s linear forwards infinite;
    animation-play-state: paused;
    transition: .5s;
    backface-visibility: hidden;
    perspective: 1000;
  }

  .progress>.bar.animating {
    animation-play-state: running;
  }

  .blind {
    pointer-events: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    min-height: 100%;
    transform: translate3d(0, 0%, 0);
    overflow: hidden;
    background: url('/images/Background.png') 0 0 repeat;
    background-color: #f4f4f2;
    background-size: 100px 100px;
    animation: loop 10s linear forwards infinite;
    transition: .5s;
    backface-visibility: hidden;
    perspective: 1000;
  }

  @keyframes fade {
    from {
        opacity: 0;
    }

    to {
        opacity: 1;
    }
  }

  @keyframes progress {
    0% {
        background-position: 0px 0px;
    }

    100% {
        background-position: -24px 0px;
    }
  }

  @keyframes loop {
    0% {
        background-position: 0 0;
    }

    100% {
        background-position: -100px 0px;
    }
  }

  @media screen and (-webkit-min-device-pixel-ratio: 2),
  (min-resolution: 2dppx) {
    .progress>.bar {
        background: url('/images/Stripes@2x.png') 0 0 repeat;
        background-color: #5200ff;
        background-size: 24px 24px;
    }

    .blind {
        background: url('/images/Background@2x.png') 0 0 repeat;
        background-color: #f4f4f2;
        background-size: 100px 100px;
    }
  }

  @media screen and (-webkit-min-device-pixel-ratio: 3),
  (min-resolution: 3dppx) {
    .progress>.bar {
        background: url('/images/Stripes@3x.png') 0 0 repeat;
        background-color: #5200ff;
        background-size: 24px 24px;
    }

    .blind {
        background: url('/images/Background@3x.png') 0 0 repeat;
        background-color: #f4f4f2;
        background-size: 100px 100px;
    }
  }
</style>
</head>
<body>
  <div id="app">
    <div class="container">
      <div class="top">
        <button class="button is-circle is-hidden" onclick="request(event)">
          <span class="icon">
            <i class="fa-solid fa-triangle-exclamation"></i>
          </span>
        </button>
      </div>
      <div class="bottom">
        <div class="level">
          <div class="level-item">
            <button class="button is-circle" onclick="previous(event)">
              <span class="icon">
                <i class="fa-solid fa-arrow-left"></i>
              </span>
            </button>
          </div>
          <div class="level-item">
            <button class="button is-circle" onclick="shuffle(event)">
              <span class="icon">
                <i class="fa-solid fa-shuffle"></i>
              </span>
            </button>
          </div>
          <div class="level-item">
            <label class="button is-circle is-primary">
              <input type="file" name="post" accept="image/gif, image/png, image/jpeg, image/webp" title="Post" onchange="post(event);">
              <span class="icon is-rotate" onselectstart="return false;" onmousedown="return false;">
                <i class="fa-solid fa-cloud-arrow-up"></i>
              </span>
            </label>
          </div>
          <div class="level-item">
            <button class="button is-circle" disabled onclick="share(event)">
              <div class="stack">
                <span class="icon">
                  <i class="fa-solid fa-link"></i>
                </span>
                <span class="icon is-hidden">
                  <i class="fa-solid fa-check"></i>
                </span>
              </div>
            </button>
          </div>
          <div class="level-item">
            <button class="button is-circle" onclick="next(event)">
              <span class="icon">
                <i class="fa-solid fa-arrow-right"></i>
              </span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
<script>
const NSFW = JSON.parse(new URL(window.location.href).searchParams.get("nsfw")) ?? true;
const MAX_SHIFT_FACTOR = 0.05;
const canvas = document.createElement("canvas");
let offscreenCanvas = null;
let pointer = {x: 0.0, y: 0.0, previous: {x: 0, y: 0}, identifier: null, time: 0};
let point = { x: 0.0, y: 0.0 };
let idleTime = 0;
const div = document.body.querySelector("#app>.container");
const rect = div.getBoundingClientRect();
const layers = [];
const posts = [];
let offset = 0;
let selected = 0;
let previousTime = performance.now();
let redrawRequired = false;
let isGranted = false;

canvas.width = Math.floor(rect.width * window.devicePixelRatio);
canvas.height = Math.floor(rect.height * window.devicePixelRatio);
canvas.style.width = `${Math.floor(rect.width)}px`;
canvas.style.height = `${Math.floor(rect.height)}px`;
canvas.style.backgroundColor = "transparent";

div.prepend(canvas);

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function shake(element) {
  element.animate([
    { transform: "translate3d(5px, 0, 0)" },
    { transform: "translate3d(0, 0, 0)" },
    { transform: "translate3d(-5px, 0, 0)" },
    { transform: "translate3d(4px, 0, 0)" },
    { transform: "translate3d(0, 0, 0)" },
    { transform: "translate3d(-4px, 0, 0)" },
    { transform: "translate3d(3px, 0, 0)" },
    { transform: "translate3d(0, 0, 0)" },
    { transform: "translate3d(-3px, 0, 0)" },
    { transform: "translate3d(2px, 0, 0)" },
    { transform: "translate3d(0, 0, 0)" },
    { transform: "translate3d(-2px, 0, 0)" },
    { transform: "translate3d(1px, 0, 0)" },
    { transform: "translate3d(0, 0, 0)" },
    { transform: "translate3d(-1px, 0, 0)" }],
    { fill: "forwards", duration: 500, iterations: 1 }).onfinish = () => {
      element.style.transform = "translate3d(0, 0, 0)";
    };
}

async function download(url = null, limit = 10, reverse = false) {
  let success = true;
  const blind = document.createElement("div");

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom .button input")) {
    element.disabled = true;
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom button.button")) {
    element.disabled = true;
  }
          
  blind.className = "blind";
  blind.style.transform = "translate3d(0, 100%, 0)";

  try {
    const response = await fetch(window.devicePixelRatio > 1 ? `/images/Background@${Math.trunc(window.devicePixelRatio)}x.png` : "/images/Background.png");

    if (response.ok) {
      const blob = await response.blob();
      const dataURL = await new Promise(async (resolve, reject) => {
        const reader = new FileReader();

        reader.onload = () => {
          resolve(reader.result);
        };
        reader.onerror = () => {
          reject(reader.error);
        };
        reader.readAsDataURL(blob);
      });
      blind.style.backgroundImage = `url('${dataURL}')`;
    }
  } catch (error) {
    console.error(error);
  }

  document.body.querySelector("#app>.container>canvas").after(blind);
  
  await new Promise(async (resolve) => {
    blind.animate([
      {
        transform: "translate3d(0, 0%, 0)"
      }
    ], {
      delay: 0,
      fill: "forwards",
      duration: 500,
      iterations: 1,
      easing: "ease-out"
    }).onfinish = () => {
      blind.style.transform = "translate3d(0, 0%, 0)";

      resolve();
    };
  });

  if (url === null) {
    try {
      if (reverse) {
        if (selected - 1 >= 0) {
          selected--;
          url = `https://milchchan.com/parallax#${posts[selected].id}`;
        } else if (offset > 0) {
          const nextOffset = Math.max(0, offset - limit);

          try {
            const response = await fetch(`https://milchchan.com/api/parallax/posts?nsfw=${NSFW ? 'true' : 'false'}&offset=${nextOffset}&limit=${limit}`, {
                mode: "cors",
                method: "GET",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                }
              }
            );

            if (response.ok) {
              const json = await response.json();

              posts.splice(0);

              for (const item of json) {
                posts.push(item);
              }

              offset = nextOffset;
              selected = posts.length - 1;
              url = `https://milchchan.com/parallax#${posts[selected].id}`;
            } else {
              throw new Error(response.statusText);
            }
          } catch (error) {
            console.error(error);
          }
        }
      } else {
        if (selected + 1 < posts.length) {
          selected++;
          url = `https://milchchan.com/parallax#${posts[selected].id}`;
        } else {
          const response = await fetch(`https://milchchan.com/api/parallax/posts?nsfw=${NSFW ? 'true' : 'false'}&offset=${offset}&limit=${limit + 1}`, {
              mode: "cors",
              method: "GET",
              headers: {
                  "Content-Type": "application/x-www-form-urlencoded"
              }
            }
          );

          if (response.ok) {
            const json = await response.json();

            if (json.length > 0) {
              posts.splice(0);

              for (const item of json) {
                posts.push(item);
              }

              if (json.length === limit + 1) {
                offset += limit;
                posts.pop();
              }

              selected = 0;
              url = `https://milchchan.com/parallax#${posts[selected].id}`;
            }
          } else {
            throw new Error(response.statusText);
          }
        }
      }
    } catch (error) {
      console.error(error);
    }
  }

  if (url === null) {
    success = false;
  } else {
    const progress = document.createElement("div");
    const bar = document.createElement("div");
  
    progress.className = "progress";
    bar.classList.add("bar");
    bar.classList.add("animating");
    bar.style.width = "0%";
    
    try {
      const response = await fetch(window.devicePixelRatio > 1 ? `/images/Stripes@${Math.trunc(window.devicePixelRatio)}x.png` : "/images/Stripes.png");

      if (response.ok) {
        const dataURL = await new Promise(async (resolve, reject) => {
          const reader = new FileReader();

          reader.onload = () => {
            resolve(reader.result);
          };
          reader.onerror = () => {
            reject(reader.error);
          };
          reader.readAsDataURL(await response.blob());
        });

        if (dataURL !== null) {
          bar.style.backgroundImage = `url('${dataURL}')`;
        }
      }
    } catch (error) {
      console.error(error);
    }

    progress.appendChild(bar);
    document.body.querySelector("#app").appendChild(progress);

    try {
      const response = await fetch(url, {
          mode: "cors",
          method: "GET"
        }
      );

      if (response.ok) {
        const json = await response.json();
        let width = 0;
        let height = 0;
        let index = 0;
        
        layers.splice(0);

        for (const item of json.layers) {
          if (item === null) {
            layers.push(null);
          } else {
            const image = await new Promise((resolve, reject)=>{
              const image = new Image();

              image.onload=()=>resolve(image);
              image.onerror = reject;
              image.src = item.url;
            });

            layers.push({image: image, weight: (index + 1) / json.layers.length});
            width = Math.max(width, image.width);
            height = Math.max(height, image.height);
          }

          if (layers.length < json.layers.length) {
            bar.animate([
              {
                width: `${Math.floor(layers.length / json.layers.length * 100)}%`
              }
            ], {
              delay: 0,
              fill: "forwards",
              duration: 500,
              iterations: 1,
              easing: "linear",
              composite: "replace"
            }).onfinish = () => {
              bar.style.width = `${Math.floor(layers.length / json.layers.length * 100)}%`;
            };
          } else {
            bar.animate([
              {
                width: `${Math.floor(layers.length / json.layers.length * 100)}%`
              }
            ], {
              delay: 0,
              fill: "forwards",
              duration: 500,
              iterations: 1,
              easing: "ease-in",
              composite: "replace"
            }).onfinish = () => {
              bar.style.width = `${Math.floor(layers.length / json.layers.length * 100)}%`;
              bar.animate([
                {
                  opacity: 0
                }
              ], {
                delay: 0,
                fill: "forwards",
                duration: 500,
                iterations: 1,
                easing: "ease-in"
              }).onfinish = () => {
                progress.remove();
              };
            };
          }

          index++;
        }

        offscreenCanvas = new OffscreenCanvas(width, height);
        redrawRequired = true;

        for (const element of document.body.querySelectorAll("#app>div.container>.bottom .level>.level-item:nth-child(3) button.button")) {
          element.dataset.id = json.id;
        }

        for (const element of document.body.querySelectorAll("#app>div.container>.bottom button.button")) {
          element.disabled = false;
        }
      } else {
        throw new Error(response.statusText);
      }
    } catch (error) {
      console.error(error);

      bar.animate([
        {
          opacity: 0
        }
      ], {
        delay: 0,
        fill: "forwards",
        duration: 500,
        iterations: 1,
        easing: "ease-in"
      }).onfinish = () => {
        progress.remove();
      };

      for (const element of document.body.querySelectorAll("#app>div.container>.bottom .level>.level-item:nth-child(-n + 2) button.button")) {
        element.disabled = false;
      }

      for (const element of document.body.querySelectorAll("#app>div.container>.bottom .level>.level-item:last-child button.button")) {
        element.disabled = false;
      }

      success = false;
    }
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom .button input")) {
    element.disabled = false;
  }

  blind.animate([
    {
      transform: "translate3d(0, -100%, 0)"
    }
  ], {
    delay: 0,
    fill: "forwards",
    duration: 500,
    iterations: 1,
    easing: "ease-out",
    composite: "replace"
  }).onfinish = () => {
    blind.remove();
  };

  return success;
}

window.request = async (event) => {
  const target = (event.currentTarget || event.target);
  const permissionState = await DeviceOrientationEvent.requestPermission();
      
  if (permissionState === "granted") {
    if (!target.classList.contains("is-hidden")) {
      target.classList.add("is-hidden");
    }
  } else {
    shake(target);
  }
};

window.previous = async (event) => {
  if (!download(null, 10, true)) {
    shake(event.currentTarget || event.target);
  }
};
window.next = async (event) => {
  if (!download(null, 10, false)) {
    shake(event.currentTarget || event.target);
  }
};
window.shuffle = async (event) => {
  if (!download("https://milchchan.com/api/parallax/post")) {
    shake(event.currentTarget || event.target);
  }
};
window.post = async (files) => {
  const target = (event.currentTarget || event.target);
  const blind = document.createElement("div");
  const progress = document.createElement("div");
  const bar = document.createElement("div");

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom .button input")) {
    element.disabled = true;
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom button.button")) {
    element.disabled = true;
  }
          
  blind.className = "blind";
  blind.style.transform = "translate3d(0, 100%, 0)";

  try {
    const response = await fetch(window.devicePixelRatio > 1 ? `/images/Background@${Math.trunc(window.devicePixelRatio)}x.png` : "/images/Background.png");

    if (response.ok) {
      const blob = await response.blob();
      const dataURL = await new Promise(async (resolve, reject) => {
        const reader = new FileReader();

        reader.onload = () => {
          resolve(reader.result);
        };
        reader.onerror = () => {
          reject(reader.error);
        };
        reader.readAsDataURL(blob);
      });
      blind.style.backgroundImage = `url('${dataURL}')`;
    }
  } catch (error) {
    console.error(error);
  }

  progress.className = "progress";
  bar.classList.add("bar");
  bar.classList.add("animating");
  bar.style.width = "0%";

  try {
    const response = await fetch(window.devicePixelRatio > 1 ? `/images/Stripes@${Math.trunc(window.devicePixelRatio)}x.png` : "/images/Stripes.png");

    if (response.ok) {
      const dataURL = await new Promise(async (resolve, reject) => {
        const reader = new FileReader();

        reader.onload = () => {
          resolve(reader.result);
        };
        reader.onerror = () => {
          reject(reader.error);
        };
        reader.readAsDataURL(await response.blob());
      });

      if (dataURL !== null) {
        bar.style.backgroundImage = `url('${dataURL}')`;
      }
    }
  } catch (error) {
    console.error(error);
  }

  progress.appendChild(bar);

  document.body.querySelector("#app>.container>canvas").after(blind);
  document.body.querySelector("#app").appendChild(progress);

  await new Promise(async (resolve) => {
    blind.animate([
      {
        transform: "translate3d(0, 0%, 0)"
      }
    ], {
      delay: 0,
      fill: "forwards",
      duration: 500,
      iterations: 1,
      easing: "ease-out"
    }).onfinish = () => {
      blind.style.transform = "translate3d(0, 0%, 0)";

      resolve();
    };
  });

  for (const file of target.files) {
    try {
      const formData = new FormData();

      formData.append("file", new Blob([file], { type: file.type }), file.name);

      const response = await fetch("https://milchchan.com/api/parallax/post", {
          mode: "cors",
          method: "POST",
          body: formData
        }
      );

      if (response.ok) {
        const json = await response.json();
        let width = 0;
        let height = 0;
        let index = 0;
        
        layers.splice(0);

        for (const item of json.layers) {
          if (item === null) {
            layers.push(null);
          } else {
            const image = await new Promise((resolve, reject)=>{
              const image = new Image();

              image.onload=()=>resolve(image);
              image.onerror = reject;
              image.src = item.url;
            });

            layers.push({image: image, weight: (index + 1) / json.layers.length});
            width = Math.max(width, image.width);
            height = Math.max(height, image.height);
          }

          if (layers.length < json.layers.length) {
            bar.animate([
              {
                width: `${Math.floor(layers.length / json.layers.length * 100)}%`
              }
            ], {
              delay: 0,
              fill: "forwards",
              duration: 500,
              iterations: 1,
              easing: "linear",
              composite: "replace"
            }).onfinish = () => {
              bar.style.width = `${Math.floor(layers.length / json.layers.length * 100)}%`;
            };
          } else {
            bar.animate([
              {
                width: `${Math.floor(layers.length / json.layers.length * 100)}%`
              }
            ], {
              delay: 0,
              fill: "forwards",
              duration: 500,
              iterations: 1,
              easing: "ease-in",
              composite: "replace"
            }).onfinish = () => {
              bar.style.width = `${Math.floor(layers.length / json.layers.length * 100)}%`;
              bar.animate([
                {
                  opacity: 0
                }
              ], {
                delay: 0,
                fill: "forwards",
                duration: 500,
                iterations: 1,
                easing: "ease-in"
              }).onfinish = () => {
                progress.remove();
              };
            };
          }

          index++;
        }

        offscreenCanvas = new OffscreenCanvas(width, height);
        redrawRequired = true;

        for (const element of document.body.querySelectorAll("#app>div.container>.bottom .level>.level-item:nth-child(3) button.button")) {
          element.dataset.id = json.id;
        }

        for (const element of document.body.querySelectorAll("#app>div.container>.bottom button.button")) {
          element.disabled = false;
        }
      } else {
        throw new Error(response.statusText);
      }
    } catch (error) {
      console.error(error);

      shake(target.parentElement);

      bar.animate([
        {
          opacity: 0
        }
      ], {
        delay: 0,
        fill: "forwards",
        duration: 500,
        iterations: 1,
        easing: "ease-in"
      }).onfinish = () => {
        progress.remove();
      };

      for (const element of document.body.querySelectorAll("#app>div.container>.bottom .level>.level-item:nth-child(-n + 2) button.button")) {
        element.disabled = false;
      }

      for (const element of document.body.querySelectorAll("#app>div.container>.bottom .level>.level-item:last-child button.button")) {
        element.disabled = false;
      }
    }

    break;
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom .button input")) {
    element.disabled = false;
  }

  blind.animate([
    {
      transform: "translate3d(0, -100%, 0)"
    }
  ], {
    delay: 0,
    fill: "forwards",
    duration: 500,
    iterations: 1,
    easing: "ease-out",
    composite: "replace"
  }).onfinish = () => {
    blind.remove();
  };
};
window.share = async (event) => {
  const target = (event.currentTarget || event.target);

  try {
    await navigator.clipboard.writeText(`https://milchchan.com/parallax#${target.dataset.id.slice(0, 7)}`);
  } catch (error) {
    console.error(error);
  }

  for (const element of target.querySelectorAll(":scope .stack .icon")) {
    if (element.classList.contains("is-hidden")) {
      element.classList.remove("is-hidden");
    } else {
      element.classList.add("is-hidden");
    }
  }

  setTimeout(() => {
    for (const element of target.querySelectorAll(":scope .stack .icon")) {
      if (element.classList.contains("is-hidden")) {
        element.classList.remove("is-hidden");
      } else {
        element.classList.add("is-hidden");
      }
    }
  }, 3000);
};
window.addEventListener("load", event => {
  const hash = decodeURIComponent(window.location.hash.substring(1));

  if (typeof DeviceOrientationEvent?.requestPermission === "function") {
    setTimeout(() => {
      if (!isGranted) {
        document.body.querySelector("#app>.container .notice>button").classList.remove("is-hidden");
      }
    }, 3000);
  }

  function render(timestamp) {
    if (timestamp > previousTime) {
      const deltaTime = (timestamp - previousTime) / 1000;

      if (timestamp - pointer.time >= 3000) {
        idleTime += deltaTime;
        pointer.y = Math.sin(idleTime * 2 * Math.PI * 0.1) * 0.5;
        redrawRequired = true;
      } else {
        idleTime = 0;
      }

      if (point.x !== pointer.x || point.y !== pointer.y) {
        const epsilon = 0.01;

        point.x = lerp(point.x, pointer.x, deltaTime * 5);
        point.y = lerp(point.y, pointer.y, deltaTime * 5);

        if (Math.abs(point.x - pointer.x) < epsilon) {
          point.x = pointer.x;
        }

        if (Math.abs(point.y - pointer.y) < epsilon) {
          point.y = pointer.y;
        }

        redrawRequired = true;
      }

      if (offscreenCanvas !== null && redrawRequired) {
        const context = canvas.getContext("2d");
        const offscreenContext = offscreenCanvas.getContext("2d");
        const maxShift = Math.round(Math.min(offscreenCanvas.width, offscreenCanvas.height) * MAX_SHIFT_FACTOR);
        const top = 0.25;
        const left = 0.5;
        const sourceWidth = offscreenCanvas.width - maxShift * 2;
        const sourceHeight = offscreenCanvas.height - maxShift * 2;
        const canvasAspect = canvas.width / canvas.height;
        const imageAspect = sourceWidth / sourceHeight;
        let sx, sy, sw, sh;
        const base = 5;

        if (canvasAspect > imageAspect) {
          const ratio = canvas.width / sourceWidth;

          sx = maxShift;
          sh = canvas.height / ratio;
          sy = Math.max(0, Math.min(sourceHeight - sh, (sourceHeight * ratio - canvas.height) / ratio * top)) + maxShift;
          sw = sourceWidth;
        } else {
          const ratio = canvas.height / sourceHeight;

          sw = canvas.width / ratio;
          sx = Math.max(0, Math.min(sourceWidth - sw, (sourceWidth * ratio - canvas.width) / ratio * left)) + maxShift;
          sy = maxShift;
          sh = sourceHeight;
        }

        offscreenContext.imageSmoothingEnabled = true;
        offscreenContext.imageSmoothingQuality = "high";
        offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);

        for (const layer of layers) {
          if (layer !== null) {
            const weight = Math.log1p((base - 1) * (1.0 - layer.weight)) / Math.log(base);
          
            offscreenContext.drawImage(layer.image, point.x * maxShift * weight, point.y * maxShift * weight);
          }
        }

        context.imageSmoothingEnabled = true;
        context.imageSmoothingQuality = "high";
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.save();
        context.drawImage(offscreenCanvas, Math.round(sx), Math.round(sy), Math.floor(sw), Math.floor(sh), 0, 0, canvas.width, canvas.height);
        context.restore();

        redrawRequired = false;
      }

      previousTime = timestamp;
    }

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);

  if (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{7})$/.test(hash)) {
    download(`https://milchchan.com/api/parallax/post/${hash}`);
  } else {
    download("https://milchchan.com/api/parallax/post");
  }
});
window.addEventListener("resize", event => {
  const rect = document.body.querySelector("#app>.container").getBoundingClientRect();

  canvas.width = Math.floor(rect.width * window.devicePixelRatio);
  canvas.height = Math.floor(rect.height * window.devicePixelRatio);
  canvas.style.width = `${Math.floor(rect.width)}px`;
  canvas.style.height = `${Math.floor(rect.height)}px`;

  redrawRequired = true;
});
window.addEventListener("mousemove", event => {
  const rect = document.body.querySelector("#app>.container").getBoundingClientRect();
  const width = rect.width / 2;
  const height = rect.height / 2;
  
  pointer.x = Math.max(Math.min((event.clientX - rect.left - width) / width, 1.0), -1.0);
  pointer.y = Math.max(Math.min((event.clientY - rect.top - height) / height, 1.0), -1.0);
  pointer.time = performance.now();

  redrawRequired = true;
});
window.addEventListener("touchstart", async event => {
  event.stopPropagation();

  if (pointer.identifier === null) {
    for (const touch of event.changedTouches) {
      pointer.previous.x = touch.clientX;
      pointer.previous.y = touch.clientY;
      pointer.identifier = touch.identifier;
      pointer.time = performance.now();
      
      break;
    }
  }
});
window.addEventListener("touchmove", async event => {
  event.stopPropagation();

  for (const touch of event.changedTouches) {
    if (touch.identifier === pointer.identifier) {
      const rect = document.body.querySelector("#app>.container").getBoundingClientRect();
      const width = rect.width / 2;
      const height = rect.height / 2;
      
      pointer.x = Math.max(Math.min(pointer.x + (touch.clientX - pointer.previous.x) / width, 1.0), -1.0);
      pointer.y = Math.max(Math.min(pointer.y + (touch.clientY - pointer.previous.y) / height, 1.0), -1.0);
      pointer.previous.x = touch.clientX;
      pointer.previous.y = touch.clientY;
      pointer.time = performance.now();
      
      redrawRequired = true;

      break;
    }
  }
});
window.addEventListener("touchend", event => {
  event.stopPropagation();

  for (const touch of event.changedTouches) {
    if (touch.identifier === pointer.identifier) {
      pointer.identifier = null;
    }
  }
});
window.addEventListener("touchcancel", event => {
  event.stopPropagation();

  for (const touch of event.changedTouches) {
    if (touch.identifier === pointer.identifier) {
      pointer.identifier = null;
    }
  }
});
window.addEventListener("deviceorientation", event => {
  if (event.beta !== null && event.gamma !== null) {
    if (pointer.identifier === null) {
      const pitch = Math.max(Math.min(event.beta, 30), -30) / 30;
      const roll = Math.max(Math.min(event.gamma, 30), -30) / 30;
    
      pointer.x = roll;
      pointer.y = pitch;
      pointer.time = performance.now();

      redrawRequired = true;
    }

    isGranted = true;
  }
}, true);
</script>
</body></html>