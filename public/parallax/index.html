<!DOCTYPE html>
<html lang="en">
  <head>
  <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-617KR1WTYP"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-617KR1WTYP");
    </script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />    
    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f4f4f2">
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#f4f4f2"> 
    <title>MILCHCHAN.COM LAX</title>
    <link rel="icon" type="image/png" href="favicon.png" />
    <link rel="apple-touch-icon" href="touch-icon-iphone.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="touch-icon-iphone-retina.png" />
    <link rel="apple-touch-icon" sizes="167x167" href="touch-icon-ipad-retina.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@400;700&display=swap" rel="stylesheet" />
    <script src="https://kit.fontawesome.com/922939073a.js" crossorigin="anonymous"></script>
    <style>
      :root {
        --background-color: rgb(255 255 255 / 0.75);
        --background-color-alt: rgb(0 0 0 / 0.75);
        --foreground-color: #000000;
        --foreground-color-alt: #ffffff;
        --accent-color: #3cffd0;
      }

      @media (prefers-color-scheme: dark) {
          :root {
              --background-color: rgb(0 0 0 / 0.75);
              --background-color-alt: rgb(255 255 255 / 0.75);
              --foreground-color: #ffffff;
              --foreground-color-alt: #000000;
          }
      }
      
      html {
        touch-action: none;
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100vh;
        height: 100dvh;
        overflow-x: hidden;
        overflow-y: auto;
        scroll-behavior: smooth;
        background: #f4f4f2;
        overscroll-behavior-x: none;
        overscroll-behavior-y: none;
      }

      body {
        position: relative;
        margin: 0;
        padding: 0;
        width: 100%;
        min-height: 100vh;
        min-height: -webkit-fill-available;
        min-height: 100dvh;
        overflow: hidden;
        background: transparent;
        font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
      }

      canvas {
        opacity: 1;
        transition: .5s ease-out;
      }

      canvas.dragging {
        opacity: 0.5;
        transition: .5s ease-in;
      }

      #app {
        position: absolute;
        display: flex;
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        flex-direction: row;
        align-items: flex-start;
        justify-content: flex-start;
      }

      .container {
        position: relative;
        margin: 0;
        padding: 0;
        width: 100%;
        max-width: 100% !important;
        height: 100%;
        animation: fade .5s ease-out forwards;
      }

      .top-left {
        z-index: 0;
        -webkit-user-select: none;
        user-select: none;
        position: absolute;
        display: flex;
        top: 16px;
        left: 16px;
        padding: env(safe-area-inset-top, 0px) 0 0 env(safe-area-inset-left, 0px);
        width: fit-content;
        height: fit-content;
        align-items: center;
      }

      .top-left .button {
        display: flex;
        margin: 0;
        padding: 0;
        width: fit-content;
        height: fit-content;
        align-items: center;
        justify-content: flex-start;
        height: fit-content !important;
      }

      .top-left .stack {
        margin: 0;
        padding: 4px 4px 4px 8px !important;
      }

      .top-left .stack>.icon {
        display: flex;
        margin: 0;
        padding: 0;
        align-items: center;
        justify-content: center;
        color: var(--foreground-color);
        backface-visibility: hidden;
        font-size: 0.75rem;
        width: 16px;
        height: 16px;
        transition: .5s
      }

      .top-left .stack>.icon.is-primary {
        color: var(--accent-color);
      }

      .top-left span:not(.icon) {
        margin: 0;
        padding: 0;
        color: var(--foreground-color);
        font-family: "Barlow", "Segoe UI", "Helvetica", "Arial", sans-serif;
        font-size: 1.0rem;
        line-height: 1.0rem;
        transition: .5s;
      }

      .top-left span:not(.icon):last-child:not(:first-child) {
        padding: 4px 8px 4px 0px;
      }

      .top-left span.is-primary {
        color: var(--accent-color);
      }

      .top-left .button {
        box-shadow: none !important;
      }

      .top-left .button span.icon {
        transition: .5s
      }

      .top-left .button:active span.icon {
        color: #5200ff;
        transition: .5s
      }

      .top-right {
        z-index: 0;
        -webkit-user-select: none;
        user-select: none;
        position: absolute;
        display: flex;
        top: 16px;
        right: 16px;
        padding: env(safe-area-inset-top, 0px) env(safe-area-inset-right, 0px) 0 0;
        width: fit-content;
        height: fit-content;
        align-items: center;
      }

      .top-right>div {
        display: flex;
        margin: 0;
        padding: 0;
        width: fit-content;
        height: fit-content;
        background-color: var(--background-color-alt);
        align-items: center;
        justify-content: flex-start;
      }

      .top-right .icon:first-child:not(:last-child) {
        display: flex;
        margin: 0;
        padding: 4px 4px 4px 8px;
        align-items: center;
        justify-content: center;
        color: var(--foreground-color-alt);
        transition: .5s;
        backface-visibility: hidden;
        font-size: 0.75rem;
        width: 16px;
        height: 16px;
      }

      .top-right span:not(.icon) {
        margin: 0;
        padding: 4px 8px 4px 0px;
        color: var(--foreground-color-alt);
        font-family: "Barlow", "Segoe UI", "Helvetica", "Arial", sans-serif;
        font-size: 1.0rem;
        line-height: 1.0rem;
      }

      .top-right span.is-primary {
        color: #5200ff !important;
      }

      .middle-right {
        z-index: 0;
        -webkit-user-select: none;
        user-select: none;
        position: absolute;
        display: flex;
        top: 50%;
        right: 16px;
        padding: env(safe-area-inset-top, 0px) env(safe-area-inset-right, 0px) env(safe-area-inset-bottom, 0px) 0;
        transform: translate(0%, -50%);
        width: fit-content;
        height: fit-content !important;
        align-items: center;
      }

      .middle-right .rotation-outer {
        display: inline-flex;
      }

      .middle-right .rotation-outer>div.rotation-inner {
        padding: 50% 0;
        height: 0;
      }

      .middle-right .rotation-outer>div.rotation-inner>div.rotate {
        display: block;
        transform-origin: top right;
        transform: rotate(-90deg) translate(-50%, 0%) rotate(180deg);
        margin-top: 0%;
        white-space: nowrap;
      }

      .middle-right span {
        margin: 0;
        padding: 0;
        color: var(--foreground-color);
        font-family: "Barlow", "Segoe UI", "Helvetica", "Arial", sans-serif;
        font-size: 0.75rem;
        line-height: 0.75rem;
        opacity: 0.75;
        transition: .5s;
      }

      .top-left.is-hidden, .top-right.is-hidden, .middle-right.is-hidden {
        opacity: 0;
        transition: .5s;
      }

      .bottom {
        z-index: 1;
        -webkit-user-select: none;
        user-select: none;
        position: absolute;
        bottom: 16px;
        left: 50%;
        padding: 0 env(safe-area-inset-right, 0px) env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
        transform: translate(-50%, 0%);
        width: fit-content;
        height: fit-content;
        transition: .5s;
      }

      .bottom>.level {
        display: flex;
        margin: -8px;
        padding: 0;
      }

      .bottom>.level>.level-item {
        margin: 0;
        padding: 8px;
      }

      .bottom>.level>.level-item .button {
        backdrop-filter: blur(16px);
      }

      .button {
        margin: 0px;
        border: 0px none transparent !important;
        padding: 16px 32px 16px 32px;
        background-color: var(--background-color);
        background-clip: padding-box !important;
        height: initial;
        backface-visibility: hidden;
        opacity: 1;
        cursor: pointer;
        box-shadow: 0 .5em 1em -.125em #0a0a0a1a, 0 0 0 1px #0a0a0a05 !important;
        transition: .5s;
      }

      .button .icon {
        pointer-events: none;
        display: flex;
        margin: 0;
        align-items: center;
        justify-content: center;
        color: var(--foreground-color);
        opacity: 1;
        transition: .5s;
        backface-visibility: hidden;
        font-size: 1.0rem;
        width: 16px;
        height: 16px;
        transition: .5s;
      }

      .button.is-primary .icon {
        color: var(--accent-color) !important;
      }

      .button:active .icon {
        color: #5200ff;
        transition: .5s;
      }

      .button:disabled .icon {
        opacity: 0.5 !important;
        transition: .5s;
      }

      .button .icon.is-hidden {
        opacity: 0 !important;
        transition: .5s;
      }

      .button.is-circle {
        display: flex;
        margin: 0px;
        border-radius: 290486px !important;
        padding: 16px !important;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1;
      }

      .button.is-hidden {
        pointer-events: none;
        opacity: 0;
        transition: .5s;
      }

      .button .stack {
        position: relative;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: flex-start;
      }

      .button .stack>.icon:not(:first-child) {
        position: absolute;
      }

      label.button>input {
        pointer-events: none;
        left: 0;
        top: 0;
        opacity: 0;
        outline: none;
        position: absolute;
        width: 100%;
        height: 100%;
      }

      label.button>input+.icon {
        display: flex;
        margin: 0;
        align-items: center;
        justify-content: center;
        color: var(--foreground-color);
        opacity: 1;
        transition: .5s;
        backface-visibility: hidden;
        font-size: 1.0rem;
        width: 16px;
        height: 16px;
      }

      label.button>input:disabled+.icon {
        opacity: 0.5 !important;
        transition: .5s;
      }

      .progress {
        pointer-events: none;
        z-index: 1;
        position: absolute;
        margin: 0 !important;
        border: 0px solid transparent;
        border-radius: 0px;
        padding: 0;
        width: 100%;
        height: fit-content;
        top: 0;
        left: 0;
        overflow: hidden;
        backface-visibility: hidden;
        background: transparent;
        touch-action: none;
      }

      .progress>.bar {
        pointer-events: none;
        z-index: 1;
        position: relative;
        top: 0;
        left: 0;
        margin: 0;
        padding: 0;
        border: 0px solid transparent;
        border-radius: 0px;
        width: 100%;
        height: 4px;
        transform: translate3d(0, 0%, 0);
        overflow: hidden;
        background: url('/images/Stripes.png') 0 0 repeat;
        background-color: #5200ff;
        background-size: 24px 24px;
        animation: progress 1s linear forwards infinite;
        animation-play-state: paused;
        transition: .5s;
        backface-visibility: hidden;
        perspective: 1000;
      }

      .progress>.bar.animating {
        animation-play-state: running;
      }

      .blind {
        z-index: 1;
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        min-height: 100%;
        transform: translate3d(0, 0%, 0);
        overflow: hidden;
        background: url('/images/Background.png') 0 0 repeat;
        background-color: #f4f4f2;
        background-size: 100px 100px;
        animation: loop 10s linear forwards infinite;
        transition: .5s;
        backface-visibility: hidden;
        perspective: 1000;
      }

      .is-uppercase {
        text-transform: uppercase;
      }

      .has-text-weight-bold {
        font-weight: bold;
      }

      @keyframes fade {
        from {
            opacity: 0;
        }

        to {
            opacity: 1;
        }
      }

      @keyframes progress {
        0% {
            background-position: 0px 0px;
        }

        100% {
            background-position: -24px 0px;
        }
      }

      @keyframes loop {
        0% {
            background-position: 0 0;
        }

        100% {
            background-position: -100px 0px;
        }
      }

      @media screen and (-webkit-min-device-pixel-ratio: 2),
      (min-resolution: 2dppx) {
        .progress>.bar {
            background: url('/images/Stripes@2x.png') 0 0 repeat;
            background-color: #5200ff;
            background-size: 24px 24px;
        }

        .blind {
            background: url('/images/Background@2x.png') 0 0 repeat;
            background-color: #f4f4f2;
            background-size: 100px 100px;
        }
      }

      @media screen and (-webkit-min-device-pixel-ratio: 3),
      (min-resolution: 3dppx) {
        .progress>.bar {
            background: url('/images/Stripes@3x.png') 0 0 repeat;
            background-color: #5200ff;
            background-size: 24px 24px;
        }

        .blind {
            background: url('/images/Background@3x.png') 0 0 repeat;
            background-color: #f4f4f2;
            background-size: 100px 100px;
        }
      }

      @media screen and (min-width: 769px) and (min-height: 769px) {
        .bottom {
          left: 16px;
          transform: translate(0%, 0%);
          transition: .5s;
        }
      }

      @media (hover: hover) {
        .top-left .button:hover span:not(.icon) {
          opacity: 0.5;
          transition: .5s
        }

        .button:hover .icon {
          opacity: 0.5;
          transition: .5s;
        }
      }
    </style>
    </head>
    <body>
      <div id="app">
        <div class="container">
          <div class="top-left is-hidden">
            <button class="button" onclick="share(event)">
              <div class="stack">
                <span class="icon">
                  <i class="fa-solid fa-link"></i>
                </span>
                <span class="icon is-primary is-hidden">
                  <i class="fa-solid fa-check"></i>
                </span>
              </div>
              <span class="has-text-weight-bold is-primary">milchchan.com/lax</span>
            </button>
          </div>
          <div class="top-right is-hidden">
            <div>
              <span class="icon is-primary">
                <i class="fa-solid fa-eye"></i>
              </span>
              <span class="has-text-weight-bold">0</span>
            </div>
          </div>
          <div class="middle-right is-hidden">
            <div class="rotation-outer">
              <div class="rotation-inner">
                <div class="rotate">
                  <span class="has-text-weight-bold is-uppercase"></span>
                </div>
              </div>
            </div>
          </div>
          <div class="bottom">
            <div class="level">
              <div class="level-item">
                <button class="button is-circle" onclick="previous(event)">
                  <span class="icon">
                    <i class="fa-solid fa-arrow-left"></i>
                  </span>
                </button>
              </div>
              <div class="level-item">
                <button class="button is-circle" onclick="next(event)">
                  <span class="icon">
                    <i class="fa-solid fa-arrow-right"></i>
                  </span>
                </button>
              </div>
              <div class="level-item">
                <button class="button is-circle" onclick="shuffle(event)">
                  <span class="icon">
                    <i class="fa-solid fa-shuffle"></i>
                  </span>
                </button>
              </div>
              <div class="level-item">
                <label class="button is-circle">
                  <input type="file" name="post" accept="image/gif, image/png, image/jpeg, image/webp" title="Post" onchange="upload(event);">
                  <span class="icon" onselectstart="return false;" onmousedown="return false;">
                    <i class="fa-solid fa-cloud-arrow-up"></i>
                  </span>
                </label>
              </div>
            </div>
          </div>
        </div>
      </div>
    <script>
const NSFW = JSON.parse(new URL(window.location.href).searchParams.get("nsfw")) ?? true;
const MAX_SHIFT_FACTOR = 0.05;
const canvas = document.createElement("canvas");
let offscreenCanvas = null;
let pointer = {x: 0.0, y: 0.0, previous: {x: 0, y: 0}, identifier: null, time: 0};
let point = { x: 0.0, y: 0.0 };
let idleTime = 0;
const div = document.body.querySelector("#app>.container");
const rect = div.getBoundingClientRect();
const animations = [];
let elapsedTime = 0.0;
let maxDuration = 0.0;
const posts = [];
let offset = 0;
let selected = 0;
let previousTime = performance.now();
let redrawRequired = false;
let isGranted = false;

class Motion {
  constructor(repeats = 1, frames = []) {
    this.repeats = repeats;
    this.time = 0.0;
    this.frames = frames;
  }

  get duration() {
    let duration = 0.0;
        
    for (const frame of this.frames) {
      duration += frame.delay;
    }
    
    if (this.repeats > 1) {
      duration *= this.repeats;
    }

    return duration;
  }

  get current() {
    let time = this.time;
    let frame = this.frames[0];
    
    if (this.repeats !== 1) {
      let duration = 0.0
      
      for (const frame of this.frames) {
        duration += frame.delay;
      }
      
      if (this.repeats > 1 && time > duration * this.repeats) {
        time = duration;
      } else {
        time = time % duration;
      }
    }
    
    if (time >= frame.delay) {
      let delay = frame.delay;
      
      for (let i = 1; i < this.frames.length; i++) {
        frame = this.frames[i];
        delay += frame.delay;
          
        if (time < delay) {
            break;
        }
      }
    }
    
    return frame;
  }
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function shake(element) {
  element.animate([
    { transform: "translate3d(5px, 0, 0)" },
    { transform: "translate3d(0, 0, 0)" },
    { transform: "translate3d(-5px, 0, 0)" },
    { transform: "translate3d(4px, 0, 0)" },
    { transform: "translate3d(0, 0, 0)" },
    { transform: "translate3d(-4px, 0, 0)" },
    { transform: "translate3d(3px, 0, 0)" },
    { transform: "translate3d(0, 0, 0)" },
    { transform: "translate3d(-3px, 0, 0)" },
    { transform: "translate3d(2px, 0, 0)" },
    { transform: "translate3d(0, 0, 0)" },
    { transform: "translate3d(-2px, 0, 0)" },
    { transform: "translate3d(1px, 0, 0)" },
    { transform: "translate3d(0, 0, 0)" },
    { transform: "translate3d(-1px, 0, 0)" }],
    { fill: "forwards", duration: 500, iterations: 1 }).onfinish = () => {
      element.style.transform = "translate3d(0, 0, 0)";
    };
}

async function download(url = null, limit = 10, reverse = false) {
  let success = true;
  const blind = document.createElement("div");

  for (const element of document.body.querySelectorAll("#app>div.container>.top-left, #app>div.container>.top-right, #app>div.container>.middle-right")) {
    element.classList.add("is-hidden");
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom button.button")) {
    element.disabled = true;
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom .button input")) {
    element.disabled = true;
  }
          
  blind.className = "blind";
  blind.style.transform = "translate3d(0, 100%, 0)";

  try {
    const response = await fetch(window.devicePixelRatio > 1 ? `/images/Background@${Math.trunc(window.devicePixelRatio)}x.png` : "/images/Background.png");

    if (response.ok) {
      const blob = await response.blob();
      const dataURL = await new Promise(async (resolve, reject) => {
        const reader = new FileReader();

        reader.onload = () => {
          resolve(reader.result);
        };
        reader.onerror = () => {
          reject(reader.error);
        };
        reader.readAsDataURL(blob);
      });
      blind.style.backgroundImage = `url('${dataURL}')`;
    }
  } catch (error) {
    console.error(error);
  }

  document.body.querySelector("#app>.container>canvas").after(blind);
  
  await new Promise(async (resolve) => {
    blind.animate([
      {
        transform: "translate3d(0, 0%, 0)"
      }
    ], {
      delay: 0,
      fill: "forwards",
      duration: 500,
      iterations: 1,
      easing: "ease-out"
    }).onfinish = () => {
      blind.style.transform = "translate3d(0, 0%, 0)";

      resolve();
    };
  });

  if (url === null) {
    try {
      if (reverse) {
        if (selected - 1 >= 0) {
          selected--;
          url = `https://milchchan.com/api/parallax/post/${posts[selected].id}`;
        } else if (offset > 0) {
          const nextOffset = offset - limit;

          if (nextOffset > 0) {
            try {
              const response = await fetch(`https://milchchan.com/api/parallax/posts?nsfw=${NSFW ? 'true' : 'false'}&offset=${nextOffset}&limit=${limit}`, {
                  mode: "cors",
                  method: "GET",
                  headers: {
                      "Content-Type": "application/x-www-form-urlencoded"
                  }
                }
              );

              if (response.ok) {
                const json = await response.json();

                posts.splice(0);

                for (const item of json) {
                  posts.push(item);
                }

                offset = nextOffset;
                selected = posts.length - 1;
                url = `https://milchchan.com/api/parallax/post/${posts[selected].id}`;
              } else {
                throw new Error(response.statusText);
              }
            } catch (error) {
              console.error(error);
            }
          }
        }
      } else {
        if (selected + 1 < posts.length) {
          selected++;
          url = `https://milchchan.com/api/parallax/post/${posts[selected].id}`;
        } else {
          const response = await fetch(`https://milchchan.com/api/parallax/posts?nsfw=${NSFW ? 'true' : 'false'}&offset=${offset}&limit=${limit + 1}`, {
              mode: "cors",
              method: "GET",
              headers: {
                  "Content-Type": "application/x-www-form-urlencoded"
              }
            }
          );

          if (response.ok) {
            const json = await response.json();

            if (json.length > 0) {
              posts.splice(0);

              for (const item of json) {
                posts.push(item);
              }

              if (json.length === limit + 1) {
                posts.pop();
                offset += limit;
                selected = 0;
                url = `https://milchchan.com/api/parallax/post/${posts[selected].id}`;
              } else if (offset === 0) {
                offset += limit;
                selected = 0;
                url = `https://milchchan.com/api/parallax/post/${posts[selected].id}`;
              }
            }
          } else {
            throw new Error(response.statusText);
          }
        }
      }
    } catch (error) {
      console.error(error);
    }
  }

  if (url === null) {
    success = false;
  } else {
    const progress = document.createElement("div");
    const bar = document.createElement("div");
  
    progress.className = "progress";
    bar.classList.add("bar");
    bar.classList.add("animating");
    bar.style.width = "0%";
    
    try {
      const response = await fetch(window.devicePixelRatio > 1 ? `/images/Stripes@${Math.trunc(window.devicePixelRatio)}x.png` : "/images/Stripes.png");

      if (response.ok) {
        const dataURL = await new Promise(async (resolve, reject) => {
          const reader = new FileReader();

          reader.onload = () => {
            resolve(reader.result);
          };
          reader.onerror = () => {
            reject(reader.error);
          };
          reader.readAsDataURL(await response.blob());
        });

        if (dataURL !== null) {
          bar.style.backgroundImage = `url('${dataURL}')`;
        }
      }
    } catch (error) {
      console.error(error);
    }

    progress.appendChild(bar);
    document.body.querySelector("#app").appendChild(progress);

    try {
      const response = await fetch(url, {
          mode: "cors",
          method: "GET"
        }
      );

      if (response.ok) {
        const json = await response.json();
        let width = 0;
        let height = 0;
        const cachedImages = {};
        const timestamp = new Date(Math.floor(json.timestamp * 1000));
        const months = ["Jan","Feb","Mar","Apr","May","Jun", "Jul","Aug","Sep","Oct","Nov","Dec"];
        const formatted = `${months[timestamp.getMonth()]} ${timestamp.getDate()}, ${timestamp.getFullYear()} ${String(timestamp.getHours()).padStart(2, "0")}:${String(timestamp.getMinutes()).padStart(2, "0")}`;
        
        animations.splice(0);

        for (const animation of json.animations) {
          if (animation.length > 0) {
            let frames = [];

            for (const frame of animation) {
              if (frame.url in cachedImages) {
                frames.push({id: frame.id, delay: 0.1, image: cachedImages[frame.url]});
              } else {
                const image = await new Promise((resolve, reject)=>{
                  const img = new Image();

                  img.onload = () => resolve(img);
                  img.onerror = reject;
                  img.src = frame.url;
                });

                frames.push({id: frame.id, delay: 0.1, image: image});
                width = Math.max(width, image.width);
                height = Math.max(height, image.height);
                cachedImages[frame.url] = image;
              }
            }

            if (frames.length > 1) {
              for (let i = frames.length - 2; i >= 0; i--) {
                frames.push({id: frames[i].id, delay: frames[i].delay, image: frames[i].image});
              }

              const length = frames.length;

              for (let i = 0; i < 3; i++) {
                for (let j = 1; j < length; j++) {
                  frames.push({id: frames[j].id, delay: frames[j].delay, image: frames[j].image});
                }
              }

              frames[0].delay = 0.5;
              frames[length - 1].delay = 3.0;
              frames[(length - 1) * 2].delay = 3.0;
              frames[frames.length - 1].delay = 2.5;
            }

            animations.push(new Motion(repeats = 1, frames = frames));
          } else {
            animations.push(null);
          }

          if (animations.length < json.animations.length) {
            bar.animate([
              {
                width: `${Math.floor(animations.length / json.animations.length * 100)}%`
              }
            ], {
              delay: 0,
              fill: "forwards",
              duration: 500,
              iterations: 1,
              easing: "linear",
              composite: "replace"
            }).onfinish = () => {
              bar.style.width = `${Math.floor(animations.length / json.animations.length * 100)}%`;
            };
          } else {
            bar.animate([
              {
                width: `${Math.floor(animations.length / json.animations.length * 100)}%`
              }
            ], {
              delay: 0,
              fill: "forwards",
              duration: 500,
              iterations: 1,
              easing: "ease-in",
              composite: "replace"
            }).onfinish = () => {
              bar.style.width = `${Math.floor(animations.length / json.animations.length * 100)}%`;
              bar.animate([
                {
                  opacity: 0
                }
              ], {
                delay: 0,
                fill: "forwards",
                duration: 500,
                iterations: 1,
                easing: "ease-in"
              }).onfinish = () => {
                progress.remove();
              };
            };
          }
        }

        offscreenCanvas = new OffscreenCanvas(width, height);
        elapsedTime = maxDuration = 0.0;
        redrawRequired = true;

        for (const element of document.body.querySelectorAll("#app>div.container>.top-left button.button")) {
          const span1 = document.createElement("span");
          const span2 = document.createElement("span");

          element.dataset.id = json.id;

          for (let i = element.children.length - 1; i >= 0; i--) {
            if (element.children[i].tagName.toLowerCase() === "span") {
              element.children[i].remove();
            }
          }

          span1.classList.add("has-text-weight-bold");
          span1.classList.add("is-primary");
          span1.textContent = "milchchan.com/lax";
          span2.classList.add("has-text-weight-bold");
          span2.textContent = `#${json.id.slice(0, 7)}`;

          element.appendChild(span1);
          element.appendChild(span2);
        }

        for (const element of document.body.querySelectorAll("#app>div.container>.top-right span:not(.icon):last-child")) {
          element.textContent = String(json.views);
        }

        for (const element of document.body.querySelectorAll("#app>div.container>.middle-right span")) {
          element.textContent = formatted;
        }
      } else {
        throw new Error(response.statusText);
      }
    } catch (error) {
      console.error(error);

      bar.animate([
        {
          opacity: 0
        }
      ], {
        delay: 0,
        fill: "forwards",
        duration: 500,
        iterations: 1,
        easing: "ease-in"
      }).onfinish = () => {
        progress.remove();
      };

      success = false;
    }
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.top-left, #app>div.container>.top-right, #app>div.container>.middle-right")) {
    element.classList.remove("is-hidden");
  }
  
  for (const element of document.body.querySelectorAll("#app>div.container>.bottom button.button")) {
    element.disabled = false;
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom .button input")) {
    element.disabled = false;
  }

  blind.animate([
    {
      transform: "translate3d(0, -100%, 0)"
    }
  ], {
    delay: 0,
    fill: "forwards",
    duration: 500,
    iterations: 1,
    easing: "ease-out",
    composite: "replace"
  }).onfinish = () => {
    blind.remove();
  };

  return success;
}

async function post(file) {
  let success = true;
  const blind = document.createElement("div");
  const progress = document.createElement("div");
  const bar = document.createElement("div");

  for (const element of document.body.querySelectorAll("#app>div.container>.top-left, #app>div.container>.top-right, #app>div.container>.middle-right")) {
    element.classList.add("is-hidden");
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom button.button")) {
    element.disabled = true;
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom .button input")) {
    element.disabled = true;
  }
          
  blind.className = "blind";
  blind.style.transform = "translate3d(0, 100%, 0)";

  try {
    const response = await fetch(window.devicePixelRatio > 1 ? `/images/Background@${Math.trunc(window.devicePixelRatio)}x.png` : "/images/Background.png");

    if (response.ok) {
      const blob = await response.blob();
      const dataURL = await new Promise(async (resolve, reject) => {
        const reader = new FileReader();

        reader.onload = () => {
          resolve(reader.result);
        };
        reader.onerror = () => {
          reject(reader.error);
        };
        reader.readAsDataURL(blob);
      });
      blind.style.backgroundImage = `url('${dataURL}')`;
    }
  } catch (error) {
    console.error(error);
  }

  progress.className = "progress";
  bar.classList.add("bar");
  bar.classList.add("animating");
  bar.style.width = "0%";

  try {
    const response = await fetch(window.devicePixelRatio > 1 ? `/images/Stripes@${Math.trunc(window.devicePixelRatio)}x.png` : "/images/Stripes.png");

    if (response.ok) {
      const dataURL = await new Promise(async (resolve, reject) => {
        const reader = new FileReader();

        reader.onload = () => {
          resolve(reader.result);
        };
        reader.onerror = () => {
          reject(reader.error);
        };
        reader.readAsDataURL(await response.blob());
      });

      if (dataURL !== null) {
        bar.style.backgroundImage = `url('${dataURL}')`;
      }
    }
  } catch (error) {
    console.error(error);
  }

  progress.appendChild(bar);

  document.body.querySelector("#app>.container>canvas").after(blind);
  document.body.querySelector("#app").appendChild(progress);

  await new Promise(async (resolve) => {
    blind.animate([
      {
        transform: "translate3d(0, 0%, 0)"
      }
    ], {
      delay: 0,
      fill: "forwards",
      duration: 500,
      iterations: 1,
      easing: "ease-out"
    }).onfinish = () => {
      blind.style.transform = "translate3d(0, 0%, 0)";

      resolve();
    };
  });

  try {
    const formData = new FormData();

    formData.append("file", new Blob([file], { type: file.type }), file.name);

    const response = await fetch("https://milchchan.com/api/parallax/post", {
        mode: "cors",
        method: "POST",
        body: formData
      }
    );

    if (response.ok) {
      const json = await response.json();
      let width = 0;
      let height = 0;
      const cachedImages = {};
      const timestamp = new Date(Math.floor(json.timestamp * 1000));
      const months = ["Jan","Feb","Mar","Apr","May","Jun", "Jul","Aug","Sep","Oct","Nov","Dec"];
      const formatted = `${months[timestamp.getMonth()]} ${timestamp.getDate()}, ${timestamp.getFullYear()} ${String(timestamp.getHours()).padStart(2, "0")}:${String(timestamp.getMinutes()).padStart(2, "0")}`;
      
      animations.splice(0);

      for (const animation of json.animations) {
        if (animation.length > 0) {
          let frames = [];

          for (const frame of animation) {
            if (frame.url in cachedImages) {
              frames.push({id: frame.id, delay: 0.1, image: cachedImages[frame.url]});
            } else {
              const image = await new Promise((resolve, reject)=>{
                const img = new Image();

                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = frame.url;
              });

              frames.push({id: frame.id, delay: 0.1, image: image});
              width = Math.max(width, image.width);
              height = Math.max(height, image.height);
              cachedImages[frame.url] = image;
            }
          }

          animations.push(new Motion(repeats = 1, frames = frames));
        } else {
          animations.push(null);
        }

        if (animations.length < json.animations.length) {
          bar.animate([
            {
              width: `${Math.floor(animations.length / json.animations.length * 100)}%`
            }
          ], {
            delay: 0,
            fill: "forwards",
            duration: 500,
            iterations: 1,
            easing: "linear",
            composite: "replace"
          }).onfinish = () => {
            bar.style.width = `${Math.floor(animations.length / json.animations.length * 100)}%`;
          };
        } else {
          bar.animate([
            {
              width: `${Math.floor(animations.length / json.animations.length * 100)}%`
            }
          ], {
            delay: 0,
            fill: "forwards",
            duration: 500,
            iterations: 1,
            easing: "ease-in",
            composite: "replace"
          }).onfinish = () => {
            bar.style.width = `${Math.floor(animations.length / json.animations.length * 100)}%`;
            bar.animate([
              {
                opacity: 0
              }
            ], {
              delay: 0,
              fill: "forwards",
              duration: 500,
              iterations: 1,
              easing: "ease-in"
            }).onfinish = () => {
              progress.remove();
            };
          };
        }
      }

      offscreenCanvas = new OffscreenCanvas(width, height);
      elapsedTime = maxDuration = 0.0;
      redrawRequired = true;

      for (const element of document.body.querySelectorAll("#app>div.container>.top-left button.button")) {
        const span1 = document.createElement("span");
        const span2 = document.createElement("span");

        element.dataset.id = json.id;

        for (let i = element.children.length - 1; i >= 0; i--) {
          if (element.children[i].tagName.toLowerCase() === "span") {
            element.children[i].remove();
          }
        }

        span1.classList.add("has-text-weight-bold");
        span1.classList.add("is-primary");
        span1.textContent = "milchchan.com/lax";
        span2.classList.add("has-text-weight-bold");
        span2.textContent = `#${json.id.slice(0, 7)}`;

        element.appendChild(span1);
        element.appendChild(span2);
      }

      for (const element of document.body.querySelectorAll("#app>div.container>.top-right span:not(.icon):last-child")) {
        element.textContent = String(json.views);
      }

      for (const element of document.body.querySelectorAll("#app>div.container>.middle-right span")) {
        element.textContent = formatted;
      }

      new Promise(async (resolve1, reject1) => {
        try {
          const response = await fetch(`https://milchchan.com/api/parallax/post/${json.id}`, {
              mode: "cors",
              method: "PUT"
            }
          );

          if (response.ok) {
            resolve1(await response.json());
          } else {
            throw new Error(response.statusText);
          }
        } catch (error) {
          reject1(error);
        }
      }).then(async value => {
        if (animations.length === value.animations.length) {
          let z = 0;

          for (const animation of value.animations) {
            if (animation.length > 1 && animations[z] !== null && animations[z].frames[0].id === animation[0].id) {
              for (const frame of animation) {
                if (frame.url in cachedImages) {
                  animations[z].frames.push({delay: 0.1, image: cachedImages[frame.url]});
                } else {
                  const image = await new Promise((resolve2, reject2)=>{
                    const img = new Image();

                    img.onload = () => resolve2(img);
                    img.onerror = reject2;
                    img.src = frame.url;
                  });

                  animations[z].frames.push({delay: 0.1, image: image});
                  cachedImages[frame.url] = image;
                }
              }

              for (let i = animations[z].frames.length - 2; i >= 0; i--) {
                animations[z].frames.push({id: animations[z].frames[i].id, delay: animations[z].frames[i].delay, image: animations[z].frames[i].image});
              }

              const length = animations[z].frames.length;

              for (let i = 0; i < 3; i++) {
                for (let j = 1; j < length; j++) {
                  animations[z].frames.push({id: animations[z].frames[j].id, delay: animations[z].frames[j].delay, image: animations[z].frames[j].image});
                }
              }

              animations[z].frames[0].delay = 0.5;
              animations[z].frames[length - 1].delay = 3.0;
              animations[z].frames[(length - 1) * 2].delay = 3.0;
              animations[z].frames[animations[z].frames.length - 1].delay = 2.5;
            }

            z += 1;
          }
        }
      }).catch(error => {
        console.error(error);
      });
    } else {
      throw new Error(response.statusText);
    }
  } catch (error) {
    console.error(error);

    bar.animate([
      {
        opacity: 0
      }
    ], {
      delay: 0,
      fill: "forwards",
      duration: 500,
      iterations: 1,
      easing: "ease-in"
    }).onfinish = () => {
      progress.remove();
    };

    success = false;
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.top-left, #app>div.container>.top-right, #app>div.container>.middle-right")) {
    element.classList.remove("is-hidden");
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom button.button")) {
    element.disabled = false;
  }

  for (const element of document.body.querySelectorAll("#app>div.container>.bottom .button input")) {
    element.disabled = false;
  }

  blind.animate([
    {
      transform: "translate3d(0, -100%, 0)"
    }
  ], {
    delay: 0,
    fill: "forwards",
    duration: 500,
    iterations: 1,
    easing: "ease-out",
    composite: "replace"
  }).onfinish = () => {
    blind.remove();
  };

  return success;
}

canvas.width = Math.floor(rect.width * window.devicePixelRatio);
canvas.height = Math.floor(rect.height * window.devicePixelRatio);
canvas.style.width = `${Math.floor(rect.width)}px`;
canvas.style.height = `${Math.floor(rect.height)}px`;
canvas.style.backgroundColor = "transparent";
canvas.addEventListener("dragenter", e => {
  (e.currentTarget || e.target).classList.add("dragging");
});
canvas.addEventListener("dragover", e => {
  e.preventDefault();
  e.dataTransfer.dropEffect = "copy";
}, false);
canvas.addEventListener("drop", async e => {
  e.stopPropagation();
  e.preventDefault();

  const target = (e.currentTarget || e.target);
  const button = document.body.querySelector("#app>.container .bottom>.level>.level-item:nth-child(4) label.button");
  const input = button.querySelector(":scope>input");

  target.classList.remove("dragging");
  input.disabled = true;

  for (const file of e.dataTransfer.files) {
    if (["image/gif", "image/png", "image/jpeg", "image/webp"].includes(file.type) && !await post(file)) {
      shake(button);
    }
    
    break;
  }

  input.disabled = false;
}, false);
canvas.addEventListener("dragleave", e => {
  (e.currentTarget || e.target).classList.remove("dragging");
});

div.prepend(canvas);

window.previous = async (event) => {
  const target = event.currentTarget || event.target;

  if (!isGranted && typeof DeviceOrientationEvent?.requestPermission === "function") {
    const permissionState = await DeviceOrientationEvent.requestPermission();
      
    if (permissionState === "granted") {
      isGranted = true;
    } else {
      shake(target);
    }
  }

  if (!await download(null, 10, true)) {
    shake(target);
  }
};
window.next = async (event) => {
  const target = event.currentTarget || event.target;

  if (!isGranted && typeof DeviceOrientationEvent?.requestPermission === "function") {
    const permissionState = await DeviceOrientationEvent.requestPermission();
      
    if (permissionState === "granted") {
      isGranted = true;
    } else {
      shake(target)
    }
  }

  if (!await download(null, 10, false)) {
    shake(target);
  }
};
window.shuffle = async (event) => {
  const target = event.currentTarget || event.target;

  if (!isGranted && typeof DeviceOrientationEvent?.requestPermission === "function") {
    const permissionState = await DeviceOrientationEvent.requestPermission();
      
    if (permissionState === "granted") {
      isGranted = true;
    } else {
      shake(target);
    }
  }

  if (!await download("https://milchchan.com/api/parallax/post")) {
    shake(target);
  }
};
window.upload = async (event) => {
  const target = (event.currentTarget || event.target);

  for (const file of target.files) {
    if (!await post(file)) {
      shake(target.parentElement);
    }

    break;
  }
};
window.share = async (event) => {
  const target = (event.currentTarget || event.target);

  try {
    await navigator.clipboard.writeText(`https://milchchan.com/lax#${target.dataset.id.slice(0, 7)}`);
  } catch (error) {
    console.error(error);
  }

  for (const element of target.querySelectorAll(":scope .stack .icon")) {
    if (element.classList.contains("is-hidden")) {
      element.classList.remove("is-hidden");
    } else {
      element.classList.add("is-hidden");
    }
  }

  setTimeout(() => {
    for (const element of target.querySelectorAll(":scope .stack .icon")) {
      if (element.classList.contains("is-hidden")) {
        element.classList.remove("is-hidden");
      } else {
        element.classList.add("is-hidden");
      }
    }
  }, 3000);
};
window.addEventListener("load", event => {
  const hash = decodeURIComponent(window.location.hash.substring(1).toLowerCase());

  function render(timestamp) {
    if (timestamp > previousTime) {
      const deltaTime = (timestamp - previousTime) / 1000;

      if (timestamp - pointer.time >= 3000) {
        idleTime += deltaTime;
        pointer.y = Math.sin(idleTime * 2 * Math.PI * 0.1) * 0.5;
        redrawRequired = true;
      } else {
        idleTime = 0;
      }
      
      if (point.x !== pointer.x || point.y !== pointer.y) {
        const epsilon = 0.01;

        point.x = lerp(point.x, pointer.x, Math.min(deltaTime * 5, 1));
        point.y = lerp(point.y, pointer.y, Math.min(deltaTime * 5, 1));

        if (Math.abs(point.x - pointer.x) < epsilon) {
          point.x = pointer.x;
        }

        if (Math.abs(point.y - pointer.y) < epsilon) {
          point.y = pointer.y;
        }

        redrawRequired = true;
      }

      if (elapsedTime < maxDuration) {
        for (const animation of animations) {
          if (animation !== null) {
            const image = animation.current.image;

            animation.time += deltaTime;

            if (image !== animation.current.image) {
              redrawRequired = true;
            }
          }
        }

        elapsedTime += deltaTime;
      } else {
        elapsedTime = 0.0;

        for (const animation of animations) {
          if (animation !== null) {
            const image = animation.current.image;

            animation.time = 0.0;

            if (animation.duration > maxDuration) {
              maxDuration = animation.duration;
            }

            if (image !== animation.current.image) {
              redrawRequired = true;
            }
          }
        }
      }

      if (offscreenCanvas !== null && redrawRequired) {
        const context = canvas.getContext("2d");
        const offscreenContext = offscreenCanvas.getContext("2d");
        const maxShift = Math.round(Math.min(offscreenCanvas.width, offscreenCanvas.height) * MAX_SHIFT_FACTOR);
        const top = 0.25;
        const left = 0.5;
        const sourceWidth = offscreenCanvas.width - maxShift * 2;
        const sourceHeight = offscreenCanvas.height - maxShift * 2;
        const canvasAspect = canvas.width / canvas.height;
        const imageAspect = sourceWidth / sourceHeight;
        let sx, sy, sw, sh;
        const base = 5;
        let index = 0;

        if (canvasAspect > imageAspect) {
          const ratio = canvas.width / sourceWidth;

          sx = maxShift;
          sh = canvas.height / ratio;
          sy = Math.max(0, Math.min(sourceHeight - sh, (sourceHeight * ratio - canvas.height) / ratio * top)) + maxShift;
          sw = sourceWidth;
        } else {
          const ratio = canvas.height / sourceHeight;

          sw = canvas.width / ratio;
          sx = Math.max(0, Math.min(sourceWidth - sw, (sourceWidth * ratio - canvas.width) / ratio * left)) + maxShift;
          sy = maxShift;
          sh = sourceHeight;
        }

        offscreenContext.imageSmoothingEnabled = true;
        offscreenContext.imageSmoothingQuality = "high";
        offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);

        for (const animation of animations) {
          if (animation !== null) {
            const weight = Math.log1p((base - 1) * (1.0 - index / animations.length)) / Math.log(base);
          
            offscreenContext.drawImage(animation.current.image, point.x * maxShift * weight, point.y * maxShift * weight);
          }

          index++;
        }

        context.imageSmoothingEnabled = true;
        context.imageSmoothingQuality = "high";
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.save();
        context.drawImage(offscreenCanvas, Math.round(sx), Math.round(sy), Math.floor(sw), Math.floor(sh), 0, 0, canvas.width, canvas.height);
        context.restore();

        redrawRequired = false;
      }

      previousTime = timestamp;
    }

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);

  if (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{7})$/.test(hash)) {
    download(`https://milchchan.com/api/parallax/post/${hash}`);
  } else {
    download(null, 10, false);
  }
});
window.addEventListener("resize", event => {
  const rect = document.body.querySelector("#app>.container").getBoundingClientRect();

  canvas.width = Math.floor(rect.width * window.devicePixelRatio);
  canvas.height = Math.floor(rect.height * window.devicePixelRatio);
  canvas.style.width = `${Math.floor(rect.width)}px`;
  canvas.style.height = `${Math.floor(rect.height)}px`;

  redrawRequired = true;
});
window.addEventListener("mousemove", event => {
  const rect = document.body.querySelector("#app>.container").getBoundingClientRect();
  const width = rect.width / 2;
  const height = rect.height / 2;
  
  pointer.x = Math.max(Math.min((event.clientX - rect.left - width) / width, 1.0), -1.0);
  pointer.y = Math.max(Math.min((event.clientY - rect.top - height) / height, 1.0), -1.0);
  pointer.time = performance.now();

  redrawRequired = true;
});
window.addEventListener("touchstart", async event => {
  event.stopPropagation();

  if (pointer.identifier === null) {
    for (const touch of event.changedTouches) {
      pointer.previous.x = touch.clientX;
      pointer.previous.y = touch.clientY;
      pointer.identifier = touch.identifier;
      pointer.time = performance.now();
      
      break;
    }
  }
});
window.addEventListener("touchmove", async event => {
  event.stopPropagation();

  for (const touch of event.changedTouches) {
    if (touch.identifier === pointer.identifier) {
      const rect = document.body.querySelector("#app>.container").getBoundingClientRect();
      const width = rect.width / 2;
      const height = rect.height / 2;
      
      pointer.x = Math.max(Math.min(pointer.x + (touch.clientX - pointer.previous.x) / width, 1.0), -1.0);
      pointer.y = Math.max(Math.min(pointer.y + (touch.clientY - pointer.previous.y) / height, 1.0), -1.0);
      pointer.previous.x = touch.clientX;
      pointer.previous.y = touch.clientY;
      pointer.time = performance.now();
      
      redrawRequired = true;

      break;
    }
  }
});
window.addEventListener("touchend", event => {
  event.stopPropagation();

  for (const touch of event.changedTouches) {
    if (touch.identifier === pointer.identifier) {
      pointer.identifier = null;
    }
  }
});
window.addEventListener("touchcancel", event => {
  event.stopPropagation();

  for (const touch of event.changedTouches) {
    if (touch.identifier === pointer.identifier) {
      pointer.identifier = null;
    }
  }
});
window.addEventListener("deviceorientation", event => {
  if (event.beta !== null && event.gamma !== null) {
    if (pointer.identifier === null) {
      const pitch = Math.max(Math.min(event.beta, 30), -30) / 30;
      const roll = Math.max(Math.min(event.gamma, 30), -30) / 30;
    
      pointer.x = roll;
      pointer.y = pitch;
      pointer.time = performance.now();

      redrawRequired = true;
    }

    isGranted = true;
  }
}, true);
window.addEventListener("keyup", async (event) => {
  if (event.code === "Space") {
    if (!await download("https://milchchan.com/api/parallax/post")) {
      shake(document.body.querySelector("#app>.container .bottom>.level>.level-item:nth-child(3) button.button"));
    }
  } else if (event.code === "ArrowLeft") {
    if (!await download(null, 10, true)) {
      shake(document.body.querySelector("#app>.container .bottom>.level>.level-item:nth-child(1) button.button"));
    }
  } else if (event.code === "ArrowRight") {
    if (!await download(null, 10, false)) {
      shake(document.body.querySelector("#app>.container .bottom>.level>.level-item:nth-child(2) button.button"));
    }
  }
});
    </script>
  </body>
</html>