<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="description" content="ミルヒちゃんもいっしょに魔法少女しようね">
    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f8f8">
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#f7f8f8">
    <meta property="og:title" content="ミルヒちゃん">
    <meta property="og:description" content="ミルヒちゃんもいっしょに魔法少女しようね">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://milchchan.com/">
    <meta property="og:image" content="https://milchchan.com/images/Milch.png">
    <meta property="twitter:card" content="summary">
    <meta property="twitter:site" content="@milchchan">
    <meta property="twitter:title" content="ミルヒちゃん">
    <meta property="twitter:description" content="ミルヒちゃんもいっしょに魔法少女しようね">
    <meta property="twitter:image" content="https://milchchan.com/images/Milch.png">
    <meta property="twitter:url" content="https://milchchan.com/">
    <title>ミルヒちゃん</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="touch-icon-iphone.png">
    <link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad.png">
    <link rel="apple-touch-icon" sizes="180x180" href="touch-icon-iphone-retina.png">
    <link rel="apple-touch-icon" sizes="167x167" href="touch-icon-ipad-retina.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Dela+Gothic+One&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/75ab01b762.js" crossorigin="anonymous"></script>
    <style type="text/css">
        :root {
            --background-color: #ffffff;
            --foreground-color: #68e6ff;
            --accent-color: #fecde2;
            --background-font-family: "Fredoka One", "Dela Gothic One", cursive;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --foreground-color: #c1aee6;
            }
        }

        html {
            touch-action: none;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            height: -webkit-fill-available;
            overflow-x: hidden;
            overflow-y: auto;
            scroll-behavior: smooth;
            background: var(--background-color);
            transition: .5s;
            overscroll-behavior-x: none;
            overscroll-behavior-y: none;
        }

        body {
            position: relative;
            margin: 0;
            padding: 0;
            width: 100%;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow: hidden;
            background: transparent;
            font-family: "Hiragino Kaku Gothic ProN", "Hiragino Sans", "Noto Sans JP", BlinkMacSystemFont, -apple-system, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", "Helvetica", "Arial", sans-serif;
        }

        a,
        a:focus,
        a:link,
        a:visited,
        a:hover,
        a:active {
            outline: none;
            text-decoration: none;
            color: #ffffff;
        }

        a .scrollable,
        button .scrollable,
        label .scrollable {
            display: inline-block;
            box-sizing: content-box;
            backface-visibility: hidden;
            transform: translate3d(0%, 0%, 0);
            transition: .5s ease-in;
        }

        a .scrollable:hover,
        button .scrollable:hover,
        label .scrollable:hover {
            display: inline-block;
            box-sizing: content-box;
            backface-visibility: hidden;
            transform: translate3d(0%, -50%, 0);
            transition: .5s ease-out;
        }

        a .scrollable>div,
        button .scrollable>div,
        label .scrollable>div {
            box-sizing: content-box;
            vertical-align: middle;
        }

        figure {
            margin: 0;
            padding: 0;
        }

        .is-superellips {
            transform: rotate(-19deg);
        }

        .is-superellips>figure {
            z-index: 1;
            position: relative;
            border-radius: 43% 57% 43% 57% / 57% 43% 57% 43% !important;
            overflow: hidden !important;
            width: fit-content;
            height: fit-content;
        }

        .is-superellips>figure>picture {
            display: block;
            transform: rotate(19deg);
        }

        .is-hidden {
            display: none;
        }

        .has-text-weight-bold {
            font-weight: bold;
        }

        div.sidebar a .scrollable:hover,
        div.sidebar button .scrollable:hover,
        div.sidebar label .scrollable:hover {
            transform: translate3d(-100%, 0%, 0);
        }

        .progress {
            pointer-events: none;
            z-index: 1;
            position: absolute;
            margin: 0 !important;
            border: 0px solid transparent;
            border-radius: 0px;
            padding: 0;
            width: 100%;
            height: fit-content;
            top: 0;
            left: 0;
            overflow: hidden;
            backface-visibility: hidden;
            background: transparent;
            touch-action: none;
        }

        .progress>.bar {
            pointer-events: none;
            z-index: 1;
            position: relative;
            top: 0;
            left: 0;
            margin: 0;
            padding: 0;
            border: 0px solid transparent;
            border-radius: 0px;
            width: 100%;
            height: 2px;
            transform: translate3d(0, 0%, 0);
            overflow: hidden;
            background: url('images/Stripes.png') 0 0 repeat;
            background-color: #ffee00;
            background-size: 24px 24px;
            animation: progress 1s linear forwards infinite;
            animation-play-state: paused;
            transition: .5s;
            backface-visibility: hidden;
            perspective: 1000;
        }

        .progress>.bar.animating {
            animation-play-state: running;
        }

        .blind {
            pointer-events: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            min-height: 100%;
            transform: translate3d(0, 0%, 0);
            overflow: hidden;
            background: url('images/Background.png') 0 0 repeat;
            background-color: rgb(247, 248, 248);
            background-size: 100px 100px;
            animation: loop 10s linear forwards infinite;
            transition: .5s;
            backface-visibility: hidden;
            perspective: 1000;
        }

        .wall {
            position: absolute;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            overflow: hidden;
            opacity: 1;
            transition: .5s ease-out;
        }

        .wall.dragging {
            opacity: 0.5;
            transition: .5s ease-in;
        }

        .wall>canvas {
            pointer-events: none;
            background: transparent;
        }

        .wall::before {
            z-index: -1;
            pointer-events: none;
            position: absolute;
            opacity: 1;
            background: transparent;
            width: 100%;
            min-height: 100%;
            content: "";
        }

        .container {
            position: relative;
            margin: 0;
            padding: 0;
            width: 100%;
            max-width: 100% !important;
            height: 100%;
        }

        #app {
            position: absolute;
            display: flex;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            flex-direction: row;
            align-items: flex-start;
            justify-content: flex-start;
        }

        #app>.container {
            position: absolute;
            overflow: hidden;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            left: 0px;
            top: 0px;
            right: 0px;
            bottom: 0px;
            margin: env(safe-area-inset-top, 0px) env(safe-area-inset-right, 0px) env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
            padding: 0;
            background: transparent;
            transition: .5s;
        }

        #app>.container>.wrap {
            box-sizing: border-box;
            position: relative;
            margin: 0;
            border-radius: 0px;
            padding: 0;
            width: 100%;
            height: 100%;
            min-height: 100%;
            background: transparent;
            overflow: hidden;
            transition: .5s;
        }

        #app>.container>.wrap>.frame {
            box-sizing: border-box;
            position: relative;
            margin: 0;
            border-radius: 0px;
            padding: 0;
            width: 100%;
            max-width: 100% !important;
            height: 100%;
            background: rgb(247, 248, 248);
            overflow: hidden;
            transform: translate3d(0, 0, 0);
            transition: .5s;
        }

        div.sidebar {
            user-select: none;
            position: relative;
            padding: env(safe-area-inset-top, 0px) 0px env(safe-area-inset-bottom, 0px) calc(env(safe-area-inset-left, 0px) + 0px);
            width: fit-content;
            height: 100%;
            background: transparent;
            transition: .5s;
        }

        div.sidebar>.level {
            display: flex;
            margin: 0;
            padding: 0;
            height: 100%;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
        }

        div.sidebar>.level>.level-item:first-child {
            position: absolute;
            top: 16px;
            margin: 0;
            padding: 0;
        }

        div.sidebar>.level>.level-item:first-child>.level {
            display: flex;
            margin: 0;
            padding: 0;
            width: 48px;
            flex-direction: column;
            align-items: flex-start;
            justify-content: center;
        }

        div.sidebar>.level>.level-item:first-child>.level>.level-item {
            margin: 0;
            padding: 0;
        }

        div.sidebar>.level>.level-item>.level>.level-item>.separator {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            width: 48px;
            height: fit-content;
        }

        div.sidebar>.level>.level-item>.level>.level-item>.separator>hr {
            border-width: 0;
            margin: 32px 0px 32px 0px;
            padding: 0;
            width: 16px;
            height: 1px;
            background-color: #000000;
            text-align: center !important;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button {
            display: flex;
            align-items: center;
            margin: 0;
            padding: 0;
            border: 0px solid transparent;
            background: transparent;
            background-clip: padding-box;
            line-height: calc(0.75rem * 1.5);
            backface-visibility: hidden;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            width: fit-content;
            height: 48px;
            cursor: pointer;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .clip {
            position: relative;
            display: flex;
            overflow: hidden;
            box-sizing: content-box;
            height: calc(0.75rem * 1.5);
            transform: translate(0px, -1px);
            box-sizing: border-box;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .clip .scrollable {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            margin: 0px -4px 0px -4px !important;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .clip .scrollable div {
            display: flex;
            align-items: center;
            margin: 0px 4px 0px 4px !important;
            font-family: "Barlow", "M PLUS Rounded 1c", sans-serif;
            font-size: 0.75rem !important;
            transform: rotate(0.03deg) !important;
            line-height: 0.75rem !important;
            height: calc(0.75rem * 1.5);
            vertical-align: middle;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .clip .scrollable div:last-child:not(:first-child) {
            position: absolute;
            left: 100%;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .icon {
            display: flex;
            margin: 0;
            padding: 0;
            color: #000000;
            width: fit-content;
            height: fit-content;
            transform: rotate(90deg);
            transition: .5s;
            line-height: 0;
            align-items: center;
            justify-content: center;
        }

        div.sidebar>.level>.level-item:first-child>.level>.level-item:first-child .button .icon figure {
            transform-origin: 50% 50%;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .icon figure>picture {
            display: block;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .icon:first-child+div {
            margin: 0px 0px 0px 16px;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .icon:not(:first-of-type) {
            margin: 0px 0px 0px 16px;
        }

        div.sidebar>.level>.level-item:first-child>.level>.level-item:not(:first-child) .button>.wrap+.icon:not(.is-animatable),
        div.sidebar>.level>.level-item:not(:first-child)>.level>.level-item .button>.icon:not(.is-animatable):first-of-type:last-of-type,
        div.sidebar>.level>.level-item:not(:first-child)>.level>.level-item .button>.wrap+.icon:not(.is-animatable) {
            opacity: 1;
            transition: .5s;
        }

        div.sidebar>.level>.level-item:first-child>.level>.level-item:not(:first-child) .button:hover>.wrap+.icon:not(.is-animatable),
        div.sidebar>.level>.level-item:not(:first-child)>.level>.level-item .button:hover>.icon:not(.is-animatable):first-of-type:last-of-type,
        div.sidebar>.level>.level-item:not(:first-child)>.level>.level-item .button:hover>.wrap+.icon:not(.is-animatable) {
            opacity: 0.5;
            transition: .5s;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .icon:not(.is-animatable) figure>picture>img {
            transform-origin: 50% 50%;
            transform: scale3d(1, 1, 1);
            transition: .5s ease-out;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button:hover .icon:not(.is-animatable) figure>picture>img {
            transform: scale3d(1.1, 1.1, 1);
            transition: .5s ease-in;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .stack .icon {
            position: absolute;
            margin: 0% 0px 0px 50% !important;
            transform-origin: 50% 50%;
            transform: translate3d(-50%, 8px, 0) rotate(90deg);
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .wrap {
            position: relative;
            display: flex;
            margin: 0;
            border-top: 2px solid transparent;
            border-bottom: 2px solid transparent;
            color: #000000;
            width: fit-content;
            height: fit-content;
            min-height: fit-content;
            box-sizing: border-box;
            overflow: hidden;
            justify-content: flex-start;
            align-items: center;
            transform: translate3d(0, 0, 0);
            transition: .5s;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button.is-selected .wrap {
            border-bottom: 2px solid #000000;
            transition: .5s ease-in;
        }

        div.sidebar>.level>.level-item:last-child:not(:first-child) {
            position: absolute;
            bottom: 16px;
            margin: 0;
            padding: 0;
        }

        div.sidebar>.level>.level-item:last-child:not(:first-child) .image>button {
            margin: 0;
            border: 0px solid transparent;
            padding: 0;
            background: transparent;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .wrap svg g>path {
            fill: #000000;
            fill-opacity: 0;
            stroke: #000000;
            stroke-opacity: 1;
            stroke-width: 1;
            stroke-dasharray: 250;
            stroke-dashoffset: 250;
            animation: draw 1s linear forwards;
            animation-play-state: paused;
            opacity: 1;
            transition: .5s;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button:hover .wrap svg g:nth-child(odd)>path {
            fill: var(--accent-color);
            stroke: var(--accent-color);
            transition: .5s;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button:hover .wrap svg g:nth-child(even)>path {
            fill: var(--foreground-color);
            stroke: var(--foreground-color);
            transition: .5s;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .icon.is-animatable>figure {
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            overflow: hidden;
            width: 32px;
            height: 32px;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .icon.is-animatable>figure>picture {
            margin-left: 0%;
            width: auto;
            height: 100%;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button:hover .icon.is-animatable>figure>picture,
        div.sidebar>.level>.level-item>.level>.level-item .button.is-selected .icon.is-animatable>figure>picture {
            animation: frame 1.33s steps(4) infinite forwards;
        }

        div.sidebar>.level>.level-item>.level>.level-item .button .icon.is-animatable>figure>picture>img {
            object-fit: none;
            object-position: 0% 0%;
            width: 100%;
            height: 100%;
        }

        div.sidebar>.level>.level-item>.level>.level-item label.button>input {
            pointer-events: none;
            left: 0;
            top: 0;
            opacity: 0;
            outline: none;
            position: absolute;
            width: 100%;
            height: 100%;
        }

        div.sidebar>.level>.level-item>.level>.level-item label.button>input:disabled+.icon {
            opacity: 0.5 !important;
            transition: .5s;
        }

        div.sidebar>.level>.level-item>.level>.level-item>.rotation-outer {
            display: table;
        }

        div.sidebar>.level>.level-item>.level>.level-item>.rotation-outer>div.rotation-inner {
            padding: 50% 0;
            height: 0;
        }

        div.sidebar>.level>.level-item>.level>.level-item>.rotation-outer>div.rotation-inner>div.rotate {
            display: block;
            transform-origin: top left;
            transform: rotate(-90deg) translate(-100%);
            margin-top: -50%;
            white-space: nowrap;
        }

        div.center {
            user-select: none;
            position: absolute;
            bottom: 50%;
            left: 50%;
            padding: 0;
            transform: translate(-50%, 50%);
            width: fit-content;
            height: fit-content;
        }

        div.remarks {
            user-select: none;
            position: absolute;
            top: 16px;
            right: 16px;
            margin: 0;
            padding: 0;
            width: fit-content;
            height: fit-content;
        }

        div.center>.level,
        div.remarks>.level {
            display: flex;
            margin: -8px;
            padding: 0;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        div.center>.level>.level-item,
        div.remarks>.level>.level-item {
            margin: 0;
            padding: 8px;
            flex-shrink: 0;
        }

        div.center>.level>.level-item>.level,
        div.remarks>.level>.level-item>.level {
            display: flex;
            margin: -8px;
            padding: 0;
            flex-direction: row;
            align-items: center;
            justify-content: center;
        }

        div.center>.level>.level-item>.level>.level-item,
        div.remarks>.level>.level-item>.level>.level-item {
            margin: 0;
            padding: 8px;
            flex-shrink: 0;
        }

        div.center .button,
        div.remarks .button {
            margin: 0px;
            border: 0px none transparent !important;
            padding: 16px 32px 16px 32px;
            background: #ffffff;
            background-clip: padding-box !important;
            height: initial;
            backface-visibility: hidden;
        }

        div.center .button.is-circle,
        div.remarks .button.is-circle {
            display: flex;
            margin: 0px;
            border-radius: 290486px !important;
            padding: 4px !important;
            width: 24px;
            height: 24px;
            align-items: center;
            justify-content: center;
        }

        div.center .button>.icon,
        div.remarks .button>.icon {
            display: flex;
            margin: 0;
            width: 16px;
            height: 16px;
            align-items: center;
            justify-content: center;
            color: #000000;
            opacity: 1;
            transition: .5s;
        }

        div.center .button:hover>.icon,
        div.remarks .button:hover>.icon {
            opacity: 0.5;
            transition: .5s;
        }

        #stats {
            user-select: none;
            display: flex;
            position: absolute;
            bottom: 16px;
            right: 16px;
            margin: 0;
            padding: 0;
            width: fit-content;
            height: fit-content;
            flex-direction: column;
            align-items: flex-end;
            justify-content: flex-start;
            opacity: 0;
            transition: .5s;
            cursor: default;
        }

        #stats.is-active {
            opacity: 1;
            transition: .5s;
        }

        #stats:hover {
            opacity: 1;
            transition: .5s;
        }

        #stats>span {
            margin: 0;
            padding: 1px;
            background-color: #000000;
            font-family: "Barlow", "M PLUS Rounded 1c", sans-serif;
            font-size: 0.75rem;
            line-height: 0.75rem;
            height: 0.75rem;
            vertical-align: middle;
            color: #ffffff;
        }

        @keyframes progress {
            0% {
                background-position: 0px 0px;
            }

            100% {
                background-position: -24px 0px;
            }
        }

        @keyframes draw {
            50% {
                stroke-opacity: 1;
                stroke-dashoffset: 0;
                fill-opacity: 0;
            }

            to {
                stroke-opacity: 0;
                stroke-dashoffset: 0;
                fill-opacity: 1;
            }
        }

        @keyframes loop {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: -100px 0px;
            }
        }

        @keyframes frame {
            0% {
                margin-left: 0%;
            }

            100% {
                margin-left: -400%;
            }
        }

        @media screen and (-webkit-min-device-pixel-ratio: 2),
        (min-resolution: 2dppx) {
            .progress>.bar {
                background: url('images/Stripes@2x.png') 0 0 repeat;
                background-color: #ffee00;
                background-size: 24px 24px;
            }

            .blind {
                background: url('images/Background@2x.png') 0 0 repeat;
                background-color: rgb(247, 248, 248);
                background-size: 100px 100px;
            }
        }

        @media screen and (-webkit-min-device-pixel-ratio: 3),
        (min-resolution: 3dppx) {
            .progress>.bar {
                background: url('images/Stripes@3x.png') 0 0 repeat;
                background-color: #ffee00;
                background-size: 24px 24px;
            }

            .blind {
                background: url('images/Background@3x.png') 0 0 repeat;
                background-color: rgb(247, 248, 248);
                background-size: 100px 100px;
            }
        }

        @media screen and (min-width: 769px) {
            #app>.container>.wrap {
                padding: 16px;
                transition: .5s;
            }

            #app>.container>.wrap>.frame {
                border-radius: 4px;
                transition: .5s;
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <div class="container">
            <div class="wrap">
                <div class="frame">
                    <div class="wall"></div>
                    <div class="sidebar">
                        <div class="level">
                            <div class="level-item">
                                <div class="level">
                                    <div class="level-item">
                                        <div class="rotation-outer">
                                            <div class="rotation-inner">
                                                <div class="rotate">
                                                    <button class="button" type="button" onclick="select(event);">
                                                        <div class="wrap" onselectstart="return false;"
                                                            onmousedown="return false;">
                                                            <svg width="136px" height="16px" viewBox="0 0 136 16"
                                                                version="1.1" xmlns="http://www.w3.org/2000/svg"
                                                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                                                xml:space="preserve" xmlns:serif="http://www.serif.com/"
                                                                style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
                                                                <g
                                                                    transform="matrix(0.333222,0,0,0.333222,-20.2079,-152.502)">
                                                                    <g transform="matrix(1,0,0,1,450.229,463.965)">
                                                                        <path
                                                                            d="M0,38.429C-3.95,34.613 -7.767,30.997 -11.517,27.047C-11.717,26.646 -12.319,27.248 -12.119,27.716L-8.303,33.609C-9.307,38.229 -13.658,41.71 -18.681,41.71C-24.572,41.71 -29.393,37.023 -29.393,30.997L-29.393,4.616C-29.393,-1.208 -24.572,-6.094 -18.681,-6.094C-15.466,-6.094 -12.521,-4.354 -10.512,-2.345L0.401,8.366C0.603,8.769 1.205,8.366 1.004,7.966L-2.946,2.207C-1.941,-2.345 2.41,-6.094 7.365,-6.094C13.324,-6.094 18.145,-1.208 18.145,4.616L18.145,30.997C18.145,41.308 6.025,44.523 0,38.429"
                                                                            style="fill-rule:nonzero;" />
                                                                    </g>
                                                                    <g transform="matrix(1,0,0,1,402.059,484.755)">
                                                                        <path
                                                                            d="M0,-6.242L-2.539,-3.767L-1.939,-0.273C-1.854,0.219 -2.058,0.715 -2.461,1.008C-2.689,1.174 -2.96,1.259 -3.231,1.259C-3.44,1.259 -3.649,1.208 -3.841,1.108L-6.979,-0.541L-10.117,1.108C-10.559,1.34 -11.093,1.302 -11.497,1.008C-11.9,0.715 -12.103,0.219 -12.019,-0.273L-11.419,-3.767L-13.958,-6.242C-14.315,-6.591 -14.443,-7.11 -14.289,-7.585C-14.135,-8.059 -13.725,-8.405 -13.231,-8.476L-9.724,-8.987L-8.154,-12.166C-7.934,-12.613 -7.478,-12.895 -6.979,-12.895C-6.479,-12.895 -6.024,-12.613 -5.804,-12.166L-4.235,-8.987L-0.727,-8.476C-0.233,-8.405 0.177,-8.059 0.331,-7.585C0.485,-7.11 0.356,-6.591 0,-6.242M-6.979,-27.096C-19.59,-27.096 -29.812,-16.875 -29.812,-4.264L-29.811,10.207C-29.811,16.233 -24.99,20.854 -19.165,20.854C-13.206,20.854 -8.52,16.233 -8.52,10.207L-8.52,7.931C-8.52,7.127 -7.85,6.458 -7.047,6.458C-6.242,6.458 -5.573,7.127 -5.573,7.931L-5.573,10.207C-5.573,16.1 -0.752,20.854 5.206,20.854C11.031,20.854 15.852,16.1 15.852,10.207L15.854,-4.264C15.854,-16.875 5.631,-27.096 -6.979,-27.096"
                                                                            style="fill-rule:nonzero;" />
                                                                    </g>
                                                                    <g transform="matrix(1,0,0,1,347.447,468.649)">
                                                                        <path
                                                                            d="M0,26.313L0,24.037C0,23.233 -0.669,22.564 -1.473,22.564C-2.276,22.564 -2.946,23.233 -2.946,24.037L-2.946,26.313C-2.946,32.338 -7.633,36.959 -13.591,36.959C-19.417,36.959 -24.237,32.338 -24.237,26.313L-24.237,-0.067C-24.237,-6.025 -19.417,-10.646 -13.591,-10.646C-7.633,-10.646 -2.946,-6.025 -2.946,-0.067L-2.946,2.344C-2.946,3.081 -2.276,3.75 -1.473,3.75C-0.669,3.75 0,3.081 0,2.344L0,-0.067C0,-5.892 4.821,-10.646 10.78,-10.646C16.604,-10.646 21.425,-5.892 21.425,-0.067L21.425,26.313C21.425,32.206 16.604,36.959 10.78,36.959C4.821,36.959 0,32.206 0,26.313"
                                                                            style="fill-rule:nonzero;" />
                                                                    </g>
                                                                    <g transform="matrix(1,0,0,1,308.547,505.541)">
                                                                        <path
                                                                            d="M0,-47.604C6.227,-47.604 11.314,-42.248 11.314,-36.221C11.314,-29.928 6.227,-24.907 0,-24.907C-3.348,-24.907 -5.959,-26.446 -7.968,-26.446C-9.373,-26.446 -10.579,-25.241 -10.579,-23.835C-10.579,-22.497 -9.373,-21.424 -7.968,-21.424C-5.959,-21.424 -3.348,-22.965 0,-22.965C6.227,-22.965 11.314,-17.608 11.314,-11.315C11.314,-5.29 6.227,0 0,0L-9.709,0C-22.563,0 -33.075,-11.18 -33.075,-23.835C-33.075,-37.092 -22.43,-47.403 -9.373,-47.604L0,-47.604Z"
                                                                            style="fill-rule:nonzero;" />
                                                                    </g>
                                                                    <g transform="matrix(1,0,0,1,251.206,468.649)">
                                                                        <path
                                                                            d="M0,26.313L0,24.037C0,23.233 -0.669,22.564 -1.473,22.564C-2.276,22.564 -2.945,23.233 -2.945,24.037L-2.945,26.313C-2.945,32.338 -7.633,36.959 -13.592,36.959C-19.416,36.959 -24.237,32.338 -24.237,26.313L-24.237,-0.067C-24.237,-6.025 -19.416,-10.646 -13.592,-10.646C-7.633,-10.646 -2.945,-6.025 -2.945,-0.067L-2.945,2.344C-2.945,3.081 -2.276,3.75 -1.473,3.75C-0.669,3.75 0,3.081 0,2.344L0,-0.067C0,-5.892 4.82,-10.646 10.779,-10.646C16.603,-10.646 21.424,-5.892 21.424,-0.067L21.424,26.313C21.424,32.206 16.603,36.959 10.779,36.959C4.82,36.959 0,32.206 0,26.313"
                                                                            style="fill-rule:nonzero;" />
                                                                    </g>
                                                                    <g transform="matrix(1,0,0,1,212.473,505.541)">
                                                                        <path
                                                                            d="M0,-47.604C6.227,-47.604 11.315,-42.248 11.315,-36.221C11.315,-29.928 6.227,-24.907 0,-24.907C-3.348,-24.907 -5.958,-26.446 -7.967,-26.446C-9.374,-26.446 -10.579,-25.241 -10.579,-23.835C-10.579,-22.497 -9.374,-21.424 -7.967,-21.424C-5.958,-21.424 -3.348,-22.965 0,-22.965C6.227,-22.965 11.315,-17.608 11.315,-11.315C11.315,-5.29 6.227,0 0,0L-9.708,0C-22.563,0 -33.075,-11.18 -33.075,-23.835C-33.075,-37.092 -22.43,-47.403 -9.374,-47.604L0,-47.604Z"
                                                                            style="fill-rule:nonzero;" />
                                                                    </g>
                                                                    <g transform="matrix(1,0,0,1,144.701,468.718)">
                                                                        <path
                                                                            d="M0,25.977L0,-0.203C0,-6.027 4.753,-10.847 10.646,-10.847C16.604,-10.847 21.358,-6.027 21.358,-0.203L21.224,15.399L23.568,15.399C37.494,15.399 37.494,36.824 23.568,36.824L10.846,36.824C4.62,36.824 -0.201,32.137 0,25.977"
                                                                            style="fill-rule:nonzero;" />
                                                                    </g>
                                                                    <g transform="matrix(1,0,0,1,119.753,468.851)">
                                                                        <path
                                                                            d="M0,25.91L0,-0.201C0,-6.027 4.687,-10.713 10.579,-10.713C16.671,-10.713 21.359,-6.027 21.359,-0.201L21.359,25.91C21.359,31.736 16.671,36.623 10.579,36.623C4.687,36.623 0,31.736 0,25.91"
                                                                            style="fill-rule:nonzero;" />
                                                                    </g>
                                                                    <g transform="matrix(1,0,0,1,105.357,505.475)">
                                                                        <path
                                                                            d="M0,-47.337C-3.737,-47.337 -5.522,-46.208 -8.863,-42.581C-12.204,-38.956 -15.61,-34.627 -15.61,-34.627C-15.449,-34.316 -12.945,-29.959 -12.908,-29.445C-12.872,-28.931 -13.349,-29.243 -13.704,-29.556C-14.141,-29.94 -22.787,-39.785 -25.106,-42.625C-27.426,-45.465 -30.289,-47.337 -34.134,-47.337C-40.026,-47.337 -44.713,-42.649 -44.713,-36.825L-44.713,-10.713C-44.713,-4.888 -40.026,0 -34.134,0C-29.87,0 -26.31,-2.4 -24.551,-5.836C-25.025,-6.555 -28.111,-11.071 -28.365,-11.704C-28.576,-12.232 -28.304,-12.14 -28.164,-12.089C-28.096,-12.064 -27.791,-11.978 -25.543,-9.718C-24.95,-9.12 -23.718,-7.989 -23.716,-7.999C-21.889,-6.554 -19.505,-5.62 -16.966,-5.62C-14.326,-5.62 -12.005,-6.548 -10.215,-7.985C-10.213,-7.98 -5.942,-11.944 -5.77,-12.089C-5.597,-12.233 -5.291,-12.232 -5.568,-11.704C-5.885,-11.101 -8.91,-6.552 -9.386,-5.831C-7.637,-2.399 -4.121,0 0,0C6.093,0 10.78,-4.888 10.78,-10.713L10.78,-36.825C10.78,-42.649 6.093,-47.337 0,-47.337"
                                                                            style="fill-rule:nonzero;" />
                                                                    </g>
                                                                </g>
                                                            </svg>
                                                        </div>
                                                        <div class="icon" onselectstart="return false;"
                                                            onmousedown="return false;">
                                                            <figure>
                                                                <picture class="image">
                                                                    <img src="images/Logo-Star.svg" width="16"
                                                                        alt="Star">
                                                                </picture>
                                                            </figure>
                                                        </div>
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="level-item">
                                        <div class="separator">
                                            <hr>
                                        </div>
                                    </div>
                                    <div class="level-item">
                                        <div class="rotation-outer">
                                            <div class="rotation-inner">
                                                <div class="rotate">
                                                    <button class="button" type="button" onclick="select(event);"
                                                        data-type="Milch">
                                                        <div class="stack">
                                                            <div class="wrap has-text-weight-bold">
                                                                <div class="clip">
                                                                    <div class="scrollable">
                                                                        <div>Milch</div>
                                                                        <div>Milch</div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            <div class="icon is-animatable"
                                                                onselectstart="return false;"
                                                                onmousedown="return false;">
                                                                <figure>
                                                                    <picture>
                                                                        <source
                                                                            srcset="images/PixelatedLuna-Transformed.png 1x, images/PixelatedLuna-Transformed@2x.png 2x, images/PixelatedLuna-Transformed@3x.png 3x"
                                                                            media="(prefers-color-scheme: dark)">
                                                                        <img src="images/PixelatedMilch-Transformed.png"
                                                                            srcset="images/PixelatedMilch-Transformed.png 1x, images/PixelatedMilch-Transformed@2x.png 2x, images/PixelatedMilch-Transformed@3x.png 3x"
                                                                            alt="Milch">
                                                                    </picture>
                                                                </figure>
                                                            </div>
                                                        </div>
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="level-item">
                                        <div class="separator">
                                            <hr>
                                        </div>
                                    </div>
                                    <div class="level-item">
                                        <div class="rotation-outer">
                                            <div class="rotation-inner">
                                                <div class="rotate">
                                                    <button class="button" type="button" onclick="select(event);"
                                                        data-type="Merku">
                                                        <div class="stack">
                                                            <div class="wrap has-text-weight-bold">
                                                                <div class="clip">
                                                                    <div class="scrollable">
                                                                        <div>Merku</div>
                                                                        <div>Merku</div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            <div class="icon is-animatable"
                                                                onselectstart="return false;"
                                                                onmousedown="return false;">
                                                                <figure>
                                                                    <picture>
                                                                        <img src="images/PixelatedMilch-Transformed.png"
                                                                            srcset="images/PixelatedMerku-Transformed.png 1x, images/PixelatedMerku-Transformed@2x.png 2x, images/PixelatedMerku-Transformed@3x.png 3x"
                                                                            alt="Merku">
                                                                    </picture>
                                                                </figure>
                                                            </div>
                                                        </div>
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="level-item">
                                <div class="level">
                                    <div class="level-item is-hidden">
                                        <div class="rotation-outer">
                                            <div class="rotation-inner">
                                                <div class="rotate">
                                                    <label class="button is-circle">
                                                        <input type="file" name="upload"
                                                            accept="image/apng, image/gif, image/png, image/jpeg, image/webp"
                                                            onchange="upload(event);">
                                                        <span class="icon" onselectstart="return false;"
                                                            onmousedown="return false;">
                                                            <i class="fa-solid fa-cloud-arrow-up fa-xs"></i>
                                                        </span>
                                                    </label>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="level-item is-hidden">
                                        <div class="separator">
                                            <hr>
                                        </div>
                                    </div>
                                    <div class="level-item">
                                        <div class="rotation-outer">
                                            <div class="rotation-inner">
                                                <div class="rotate">
                                                    <a class="button" href="https://clock.milchchan.com/">
                                                        <div class="icon" onselectstart="return false;"
                                                            onmousedown="return false;">
                                                            <i class="fa-solid fa-clock fa-xs"></i>
                                                        </div>
                                                    </a>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="level-item">
                                        <div class="separator">
                                            <hr>
                                        </div>
                                    </div>
                                    <div class="level-item">
                                        <div class="rotation-outer">
                                            <div class="rotation-inner">
                                                <div class="rotate">
                                                    <a class="button"
                                                        href="https://www.microsoft.com/store/apps/9WZDNCRDT09Q"
                                                        target="_blank">
                                                        <div class="icon" onselectstart="return false;"
                                                            onmousedown="return false;">
                                                            <div class="is-superellips">
                                                                <figure>
                                                                    <picture class="image">
                                                                        <source
                                                                            srcset="images/Merku-16.png 1x,images/Merku-32.png 2x,images/Merku-48.png 3x"
                                                                            media="(prefers-color-scheme: dark)">
                                                                        <img src="images/Milch-16.png"
                                                                            srcset="images/Milch-16.png 1x,images/Milch-32.png 2x,images/Milch-48.png 3x"
                                                                            width="16" height="16" alt="Logo">
                                                                    </picture>
                                                                </figure>
                                                            </div>
                                                        </div>
                                                        <div class="wrap has-text-weight-bold">
                                                            <div class="clip">
                                                                <div class="scrollable">
                                                                    <div>Apricot</div>
                                                                    <div>Apricot</div>
                                                                </div>
                                                            </div>
                                                        </div>
                                                        <div class="icon" onselectstart="return false;"
                                                            onmousedown="return false;">
                                                            <i class="fa-solid fa-up-right-from-square fa-xs"></i>
                                                        </div>
                                                    </a>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="remarks">
                        <div class="level">
                            <div class="level-item">
                                <a class="button is-circle" href="https://twitter.com/milchchan" target="_blank"><span
                                        class="icon" onselectstart="return false;" onmousedown="return false;"><i
                                            class="fa-brands fa-twitter fa-xs"></i></span></a>
                            </div>
                            <div class="level-item">
                                <a class="button is-circle" href="https://instagram.com/milchchan" target="_blank"><span
                                        class="icon" onselectstart="return false;" onmousedown="return false;"><i
                                            class="fab fa-instagram fa-xs"></i></span></a>
                            </div>
                            <div class="level-item">
                                <a class="button is-circle"
                                    href="https://www.youtube.com/channel/UCfL-rgK8MnI31mFrW2-js9A"
                                    target="_blank"><span class="icon" onselectstart="return false;"
                                        onmousedown="return false;"><i class="fab fa-youtube fa-xs"></i></span></a>
                            </div>
                            <div class="level-item">
                                <a class="button is-circle" href="https://github.com/milchchan" target="_blank"><span
                                        class="icon" onselectstart="return false;" onmousedown="return false;"><i
                                            class="fab fa-github fa-xs"></i></span></a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
        import { getDatabase, get, push, runTransaction, query, ref as databaseRef, child, orderByChild, startAt, limitToFirst, limitToLast } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";
        import { getStorage, ref as storageRef, getDownloadURL, getMetadata, uploadBytesResumable } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-storage.js";
        import { initializeAnalytics } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-analytics.js";

        const background = { updated: 0, timeout: 60 * 1000, preloading: false, color: null, blocks: [], index: 0, queue: [], particles: [], cache: [] };
        const tracker = { active: false, touching: false, edge: true, position: { x: 0, y: 0 }, movement: { x: 0, y: 0 }, velocity: { x: 0, y: 0 }, timestamp: 0 };
        const firebaseConfig = {
            apiKey: "AIzaSyDTVxDJj7rqG9L-Clvba2Tao9B0hkcxjcE",
            authDomain: "auth.milchchan.com",
            databaseURL: "https://milchchan.firebaseio.com",
            projectId: "milchchan",
            storageBucket: "milchchan.appspot.com",
            messagingSenderId: "355698971889",
            appId: "1:355698971889:web:e3653c5c31bd7289cd4550",
            measurementId: "G-3998FJYNWX"
        };
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        const storage = getStorage(app);

        initializeAnalytics(app);

        class APNG {
            constructor() {
                this.PNG_SIGNATURE_BYTES = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
                this.crc32Table = new Uint32Array(256);

                for (let i = 0; i < 256; i++) {
                    let c = i;

                    for (let k = 0; k < 8; k++) {
                        c = (c & 1) ? 0xEDB88320 ^ (c >>> 1) : c >>> 1;
                    }

                    this.crc32Table[i] = c;
                }
            }

            get signature() {
                return this.PNG_SIGNATURE_BYTES;
            }

            load(blob) {
                return new Promise(async (resolve1, reject1) => {
                    const self = this;
                    const bytes = new Uint8Array(await blob.arrayBuffer());

                    if (this.signature.every((element, index) => element === bytes[index])) {
                        let isAnimatable = false;

                        this.parseChunks(bytes, (type) => {
                            if (type === "acTL") {
                                isAnimatable = true;

                                return false;
                            }

                            return true;
                        });

                        if (isAnimatable) {
                            const preDataParts = [];
                            const postDataParts = [];
                            let headerDataBytes = null;
                            let frame = null;
                            const animation = { frames: [] };
                            const frames = [];

                            this.parseChunks(bytes, (type, bytes, offset, length) => {
                                switch (type) {
                                    case "IHDR":
                                        headerDataBytes = bytes.subarray(offset + 8, offset + 8 + length);
                                        animation.width = self.readDWord(bytes, offset + 8);
                                        animation.height = self.readDWord(bytes, offset + 12);

                                        break;

                                    case "acTL":
                                        animation.iterations = self.readDWord(bytes, offset + 8 + 4);

                                        break;

                                    case "fcTL":
                                        if (frame) {
                                            animation.frames.push(frame);
                                        }

                                        frame = {};
                                        frame.width = self.readDWord(bytes, offset + 8 + 4);
                                        frame.height = self.readDWord(bytes, offset + 8 + 8);
                                        frame.left = self.readDWord(bytes, offset + 8 + 12);
                                        frame.top = self.readDWord(bytes, offset + 8 + 16);

                                        const delayN = self.readWord(bytes, offset + 8 + 20);
                                        let delayD = self.readWord(bytes, offset + 8 + 22);

                                        if (delayD === 0) {
                                            delayD = 100;
                                        }

                                        frame.delay = delayN / delayD;

                                        if (frame.delay <= 0.01) {
                                            frame.delay = 0.1;
                                        }

                                        animation.playTime += frame.delay;
                                        frame.disposeOp = bytes[offset + 8 + 24];
                                        frame.blendOp = bytes[offset + 8 + 25];
                                        frame.dataParts = [];

                                        break;

                                    case "fdAT":
                                        if (frame) {
                                            frame.dataParts.push(bytes.subarray(offset + 8 + 4, offset + 8 + length));
                                        }

                                        break;

                                    case "IDAT":
                                        if (frame) {
                                            frame.dataParts.push(bytes.subarray(offset + 8, offset + 8 + length));
                                        }

                                        break;

                                    case "IEND":
                                        postDataParts.push(self.subBuffer(bytes, offset, 12 + length));

                                        break;

                                    default:
                                        preDataParts.push(self.subBuffer(bytes, offset, 12 + length));
                                }
                            });

                            if (frame !== null) {
                                animation.frames.push(frame);
                            }

                            if (animation.frames.length > 0) {
                                const preBlob = new Blob(preDataParts);
                                const postBlob = new Blob(postDataParts);
                                const canvas = document.createElement("canvas");

                                canvas.width = animation.width;
                                canvas.height = animation.height;

                                const ctx = canvas.getContext("2d", { willReadFrequently: true });

                                ctx.imageSmoothingEnabled = true;
                                ctx.imageSmoothingQuality = "high";
                                ctx.clearRect(0, 0, canvas.width, canvas.height);

                                for (const frame of animation.frames) {
                                    const chunks = [];
                                    let imageData;

                                    chunks.push(this.signature);
                                    headerDataBytes.set(this.buildDWordArray(frame.width), 0);
                                    headerDataBytes.set(this.buildDWordArray(frame.height), 4);
                                    chunks.push(this.buildChunkBytes("IHDR", headerDataBytes));
                                    chunks.push(preBlob);

                                    for (let j = 0; j < frame.dataParts.length; j++) {
                                        chunks.push(this.buildChunkBytes("IDAT", frame.dataParts[j]));
                                    }

                                    chunks.push(postBlob);

                                    if (frame.disposeOp === 2) {
                                        imageData = ctx.getImageData(frame.left, frame.top, frame.width, frame.height);
                                    } else {
                                        imageData = null;
                                    }

                                    if (frame.blendOp === 0) {
                                        ctx.clearRect(frame.left, frame.top, frame.width, frame.height);
                                    }

                                    try {
                                        frames.push({
                                            delay: frame.delay, blob: await new Promise(async (resolve2, reject2) => {
                                                const reader = new FileReader();

                                                reader.onload = () => {
                                                    const image = new Image();

                                                    image.onload = () => {
                                                        ctx.drawImage(image, frame.left, frame.top, frame.width, frame.height);
                                                        ctx.canvas.toBlob(async (blob) => {
                                                            resolve2(blob);
                                                        }, "image/png");
                                                    };
                                                    image.onerror = (error) => {
                                                        reject2(error);
                                                    };
                                                    image.crossOrigin = "anonymous";
                                                    image.src = reader.result;
                                                };
                                                reader.onerror = () => {
                                                    reject2(reader.error);
                                                };
                                                reader.readAsDataURL(new Blob(chunks, { "type": "image/png" }));
                                            })
                                        });
                                    } catch (error) {
                                        ctx.canvas.width = ctx.canvas.height = 0;

                                        reject1(error);

                                        return;
                                    } finally {
                                        delete frame.dataParts;
                                    }

                                    if (frame.disposeOp === 1) {
                                        ctx.clearRect(frame.left, frame.top, frame.width, frame.height);
                                    } else if (imageData !== null) {
                                        ctx.putImageData(imageData, frame.left, frame.top);
                                    }
                                }

                                ctx.canvas.width = ctx.canvas.height = 0;

                                resolve1([frames, animation.iterations]);

                                return;
                            }
                        }
                    }

                    resolve1(null);
                });
            }

            parseChunks(bytes, callback) {
                let offset = 8;
                let type;
                let done;

                do {
                    const length = this.readDWord(bytes, offset);

                    type = this.readString(bytes, offset + 4, 4);
                    done = callback(type, bytes, offset, length);
                    offset += 12 + length;
                } while (done !== false && type != "IEND" && offset < bytes.length);
            }

            readDWord(bytes, offset) {
                let x = 0;

                // Force the most-significant byte to unsigned.
                x += ((bytes[0 + offset] << 24) >>> 0);

                for (let i = 1; i < 4; i++) {
                    x += ((bytes[i + offset] << ((3 - i) * 8)));
                }

                return x;
            }

            readWord(bytes, offset) {
                let x = 0;

                for (let i = 0; i < 2; i++) {
                    x += (bytes[i + offset] << ((1 - i) * 8));
                }

                return x;
            }

            subBuffer(bytes, start, length) {
                const a = new Uint8Array(length);

                a.set(bytes.subarray(start, start + length));

                return a;
            }

            readString(bytes, offset, length) {
                const chars = Array.prototype.slice.call(bytes.subarray(offset, offset + length));

                return String.fromCharCode.apply(String, chars);
            }

            buildDWordArray(x) {
                return [(x >>> 24) & 0xff, (x >>> 16) & 0xff, (x >>> 8) & 0xff, x & 0xff];
            }

            buildStringArray(x) {
                const buffer = [];

                for (let i = 0; i < x.length; i++) {
                    buffer.push(x.charCodeAt(i));
                }

                return buffer;
            }

            buildChunkBytes(type, dataBytes) {
                const crcLen = type.length + dataBytes.length;
                const bytes = new Uint8Array(new ArrayBuffer(crcLen + 8));

                bytes.set(this.buildDWordArray(dataBytes.length), 0);
                bytes.set(this.buildStringArray(type), 4);
                bytes.set(dataBytes, 8);

                const crc = this.crc32(bytes, 4, crcLen);

                bytes.set(this.buildDWordArray(crc), crcLen + 4);

                return bytes;
            }

            crc32(bytes, start, length) {
                start = start || 0;
                length = length || (bytes.length - start);

                let crc = -1;

                for (let i = start, l = start + length; i < l; i++) {
                    crc = (crc >>> 8) ^ this.crc32Table[(crc ^ bytes[i]) & 0xFF];
                }

                return crc ^ (-1);
            }
        }

        function random(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);

            return Math.floor(Math.random() * (max - min)) + min;
        }

        function shuffle(array) {
            const a = [].concat(array);
            let n = array.length;

            while (n > 1) {
                const k = random(0, n);

                n--;

                const temp = a[n];

                a[n] = a[k];
                a[k] = temp;
            }

            return a;
        }

        function shake(element) {
            element.animate([
                { transform: "translate3d(0, 0, 0)" },
                { transform: "translate3d(8px, 0, 0)" },
                { transform: "translate3d(-8px, 0, 0)" },
                { transform: "translate3d(7px, 0, 0)" },
                { transform: "translate3d(-7px, 0, 0)" },
                { transform: "translate3d(6px, 0, 0)" },
                { transform: "translate3d(-6px, 0, 0)" },
                { transform: "translate3d(5px, 0, 0)" },
                { transform: "translate3d(-5px, 0, 0)" },
                { transform: "translate3d(4px, 0, 0)" },
                { transform: "translate3d(-4px, 0, 0)" },
                { transform: "translate3d(3px, 0, 0)" },
                { transform: "translate3d(-3px, 0, 0)" },
                { transform: "translate3d(2px, 0, 0)" },
                { transform: "translate3d(-2px, 0, 0)" },
                { transform: "translate3d(1px, 0, 0)" },
                { transform: "translate3d(-1px, 0, 0)" },
                { transform: "translate3d(0, 0, 0)" }],
                { duration: 1000, iterations: 1 });
        }

        async function upload(files) {
            function generateUuid() {
                // https://github.com/GoogleChrome/chrome-platform-analytics/blob/master/src/internal/identifier.js
                // const FORMAT: string = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
                let chars = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".split("");

                for (let i = 0, len = chars.length; i < len; i++) {
                    switch (chars[i]) {
                        case "x":
                            chars[i] = Math.floor(Math.random() * 16).toString(16);
                            break;
                        case "y":
                            chars[i] = (Math.floor(Math.random() * 4) + 8).toString(16);
                            break;
                    }
                }

                return chars.join("");
            }

            const progress = document.createElement("div");
            const bar = document.createElement("div");
            const completed = [];
            let animation = null;

            progress.className = "progress";
            bar.className = "bar animating";
            bar.style.width = "0%";

            try {
                const response = await fetch(window.devicePixelRatio > 1 ? `images/Stripes@${window.devicePixelRatio}x.png` : "images/Stripes.png");

                if (response.ok) {
                    const dataURL = await new Promise(async (resolve, reject) => {
                        const reader = new FileReader();

                        reader.onload = () => {
                            resolve(reader.result);
                        };
                        reader.onerror = () => {
                            reject(reader.error);
                        };
                        reader.readAsDataURL(await response.blob());
                    });

                    if (dataURL !== null) {
                        bar.style.backgroundImage = `url('${dataURL}')`;
                    }
                }
            } catch (error) {
                console.error(error);
            }

            progress.appendChild(bar);
            document.body.querySelector("#app").appendChild(progress);

            for (const file of files) {
                if (file.type.startsWith("image/")) {
                    const uploadTask = uploadBytesResumable(storageRef(storage, `images/${generateUuid()}`), file, {
                        contentType: file.type
                    });

                    try {
                        const path = await new Promise(function (resolve, reject) {
                            uploadTask.on("state_changed", (snapshot) => {
                                animation = bar.animate([
                                    {
                                        width: `${Math.floor((snapshot.bytesTransferred / snapshot.totalBytes / files.length + completed.length / files.length) * 100)}%`
                                    }
                                ], {
                                    delay: 0,
                                    fill: "forwards",
                                    duration: 500,
                                    iterations: 1,
                                    easing: "linear",
                                    composite: "replace"
                                }).onfinish = () => {
                                    bar.style.width = `${Math.floor((completed.length + 1) / files.length * 100)}%`;
                                };
                            }, (error) => {
                                reject(error);
                            }, () => {
                                resolve(uploadTask.snapshot.ref.fullPath);
                            });
                        });

                        await runTransaction(databaseRef(database, `images/${push(child(databaseRef(database), "images")).key}`), current => {
                            return { path: path, type: file.type, random: Math.random(), timestamp: Math.floor(new Date() / 1000) };
                        });

                        completed.push(path);
                    } catch (error) {
                        console.error(error);

                        animation = null;

                        break;
                    }
                }
            }

            if (animation === null || animation.playState === "finished") {
                bar.animate([
                    {
                        opacity: 0
                    }
                ], {
                    delay: 0,
                    fill: "forwards",
                    duration: 500,
                    iterations: 1,
                    easing: "ease-in"
                }).onfinish = () => {
                    progress.remove();
                };
            } else {
                bar.animate([
                    {
                        width: "100%"
                    }
                ], {
                    delay: 0,
                    fill: "forwards",
                    duration: 500,
                    iterations: 1,
                    easing: "ease-in",
                    composite: "replace"
                }).onfinish = () => {
                    bar.style.width = "100%";
                    bar.animate([
                        {
                            opacity: 0
                        }
                    ], {
                        delay: 0,
                        fill: "forwards",
                        duration: 500,
                        iterations: 1,
                        easing: "ease-in"
                    }).onfinish = () => {
                        progress.remove();
                    };
                };
            }

            return [completed, completed.length === files.length];
        }

        window.select = (event) => {
            const target = (event.currentTarget || event.target);

            if ("dataset" in background) {
                if ("type" in target.dataset) {
                    for (const element of document.body.querySelectorAll("div.sidebar>.level>.level-item:first-child>.level>.level-item .button")) {
                        if ("type" in element.dataset) {
                            if (element.dataset.type === target.dataset.type) {
                                const index = background.dataset.findIndex(x => x.type === target.dataset.type);

                                if (index >= 0) {
                                    background.index = index;
                                    background.updated = -background.timeout;
                                    element.classList.add("is-selected");
                                } else {
                                    element.classList.remove("is-selected");

                                    shake(target.querySelector(":scope .wrap"));
                                }
                            } else {
                                element.classList.remove("is-selected");
                            }
                        }
                    }
                } else {
                    const index = background.dataset.findIndex(x => "type" in x === false);

                    if (index >= 0) {
                        background.index = index;
                        background.updated = -background.timeout;;
                    } else {
                        shake(target.querySelector(":scope .wrap"));
                    }

                    for (const element of document.body.querySelectorAll("div.sidebar>.level>.level-item:first-child>.level>.level-item .button")) {
                        if ("type" in element.dataset) {
                            element.classList.remove("is-selected");
                        }
                    }
                }
            } else {
                shake(target.querySelector(":scope .wrap"));
            }
        };
        window.upload = async (event) => {
            const target = (event.currentTarget || event.target);

            if ("files" in target) {
                target.disabled = true;

                const [stack, completed] = await upload(target.files);

                if (stack.length > 0) {
                    background.queue.splice(0);

                    do {
                        background.queue.unshift({ index: 0, data: { color: "#ffffff", frames: [{ delay: 0, source: `gs://milchchan.appspot.com/${stack.pop()}` }] } });
                    } while (stack.length > 0);

                    background.updated = -background.timeout;;
                }

                if (!completed) {
                    shake(target.parentElement);
                }

                target.disabled = false;
            }
        };

        window.addEventListener("load", async event => {
            const logo = document.body.querySelector("div.sidebar>.level>.level-item:first-child>.level>.level-item:first-child .button .icon figure");
            const wall = document.body.querySelector("#app>.container>.wrap>.frame>.wall");
            const stats = document.createElement("div");
            const canvas = document.createElement("canvas");
            const rect = wall.getBoundingClientRect();

            wall.addEventListener("dragenter", e => {
                (e.currentTarget || e.target).classList.add("dragging");
            });
            wall.addEventListener("dragover", e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = "copy";
            }, false);
            wall.addEventListener("drop", async e => {
                e.stopPropagation();
                e.preventDefault();

                const target = (e.currentTarget || e.target);
                const input = document.body.querySelector("div.sidebar>.level>.level-item>.level>.level-item label.button>input");

                target.classList.remove("dragging");
                input.disabled = true;

                const [stack, completed] = await upload(e.dataTransfer.files);

                if (stack.length > 0) {
                    background.queue.splice(0);

                    do {
                        background.queue.unshift({ index: 0, data: { color: "#ffffff", frames: [{ delay: 0, source: `gs://milchchan.appspot.com/${stack.pop()}` }] } });
                    } while (stack.length > 0);

                    background.updated = -background.timeout;;
                }

                if (!completed) {
                    shake(target.parentElement);
                }

                input.disabled = false;
            }, false);
            wall.addEventListener("dragleave", e => {
                (e.currentTarget || e.target).classList.remove("dragging");
            });

            stats.id = "stats";

            if (decodeURIComponent(window.location.hash.substring(1)) === "debug") {
                stats.className = "is-active";
            }

            canvas["backBuffer"] = document.createElement("canvas");
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            canvas.style.backgroundColor = "transparent";

            wall.appendChild(canvas);

            const animation = logo.animate([
                {
                    transform: "rotate(0deg)"
                },
                {
                    transform: "rotate(360deg)"
                }
            ], {
                delay: 0,
                fill: "forwards",
                duration: 1000,
                iterations: Infinity,
                easing: "linear"
            });

            try {
                const response = await fetch(encodeURI("feed.json"), {
                    mode: "cors",
                    method: "GET",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded"
                    }
                });

                if (response.ok) {
                    background["dataset"] = await response.json();
                } else {
                    throw new Error(response.statusText);
                }

                for (const source of ["images/Star1-Light.svg", "images/Star1-Dark.svg", "images/Star2-Light.svg", "images/Star2-Dark.svg", "images/Star3-Light.svg", "images/Star3-Dark.svg", "images/Star4-Light.svg", "images/Star4-Dark.svg"]) {
                    background.cache.push(await new Promise((resolve, reject) => {
                        const image = new Image();

                        image.onload = () => {
                            resolve(image);
                        };
                        image.onerror = (error) => {
                            reject(error);
                        };
                        image.src = source
                    }));
                }
            } catch (error) {
                console.error(error);
            }

            if (background["dataset"] !== null) {
                async function download(url, handler = null) {
                    try {
                        const response = await fetch(url);

                        if (response.ok) {
                            const reader = response.body.getReader();
                            const contentType = response.headers.get("Content-Type");
                            const contentLength = +response.headers.get("Content-Length");
                            const chunks = [];
                            let receivedLength = 0;

                            while (true) {
                                const { done, value } = await reader.read();

                                if (done) {
                                    break;
                                }

                                chunks.push(value);
                                receivedLength += value.length;

                                if (handler !== null) {
                                    handler(receivedLength / contentLength);
                                }
                            }

                            if (contentType === "application/json") {
                                return new TextDecoder("utf-8").decode(chunks.reduce((x, y) => {
                                    x.buffer.set(y, x.position);
                                    x.position += chunk.length;

                                    return x;
                                }, { buffer: new Uint8Array(receivedLength), position: 0 }).buffer);
                            } else {
                                return new Blob(chunks, { type: contentType });
                            }
                        }
                    } catch (error) {
                        console.error(error);
                    }

                    return null;
                }

                for (const element of document.body.querySelectorAll("div.sidebar>.level>.level-item>.level>.level-item .button .wrap svg g>path")) {
                    element.style.animationPlayState = "running";
                }

                logo.animate([
                    {
                        transform: "rotate(360deg)"
                    }
                ], {
                    delay: 0,
                    fill: "forwards",
                    duration: 1000 - animation.currentTime % 1000,
                    iterations: 1,
                    easing: "linear"
                });
                animation.cancel();

                let previousTime = performance.now();
                const cache = {};
                const animationQueue = [];
                const fps = { time: previousTime, frames: 0, target: document.createElement("span") };

                fps.target.className = "has-text-weight-bold";
                fps.target.innerText = "0";
                fps.target.style.opacity = "0";

                stats.appendChild(fps.target);
                document.body.querySelector("#app>.container>.wrap>.frame").appendChild(stats);

                fps.target.animate([
                    {
                        opacity: "1"
                    }
                ], {
                    fill: "forwards",
                    duration: 500,
                    iterations: 1,
                    easing: "ease-out"
                });

                async function render(timestamp) {
                    if (timestamp > previousTime) {
                        const deltaTime = (timestamp - previousTime) / 1000;

                        previousTime = timestamp;

                        if (timestamp - background.updated >= background.timeout) {
                            for (const block of background.blocks) {
                                for (let i = block.inlines.length - 1; i >= 0; i--) {
                                    if (block.inlines[i].running) {
                                        block.inlines[i].type.reverse = true;
                                    }
                                }
                            }

                            background.updated = timestamp;
                        }

                        if (!background.preloading && !background.blocks.some(x => x.inlines.some(y => y.running || y.type.elapsed >= 0 || y.type.reverse)) && background.dataset.length > 0 && background.dataset[background.index].texts.length > 0) {
                            background.preloading = true;
                            background.image = null;
                            background.blocks.splice(0);
                            tracker.movement.x = tracker.movement.y = 0;
                            animationQueue.splice(0);

                            for (const item of background.dataset) {
                                for (let i = item.texts.length - 1; i >= 0; i--) {
                                    if (Array.isArray(item.texts[i])) {
                                        item.texts.splice(i, 1);
                                    }
                                }

                                if ("images" in item) {
                                    for (let i = item.images.length - 1; i >= 0; i--) {
                                        if (item.images[i].frames.some(x => x.source.startsWith("gs:"))) {
                                            item.images.splice(i, 1);
                                        }
                                    }
                                }
                            }

                            try {
                                const snapshot = await get(query(databaseRef(database, "bot/likes"), orderByChild("timestamp"), limitToLast(100)));

                                if (snapshot.exists()) {
                                    const likes = snapshot.val();

                                    for (const key in likes) {
                                        if (Array.isArray(likes[key].text)) {
                                            for (const item of background.dataset) {
                                                if ("type" in item === false) {
                                                    item.texts.push(likes[key].text);
                                                }
                                            }
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error(error);
                            }

                            try {
                                const snapshot = await get(query(databaseRef(database, "images"), orderByChild("random"), startAt(Math.random()), limitToFirst(10)));

                                if (snapshot.exists()) {
                                    function choice(collection, func) {
                                        const r = Math.random();
                                        let sum = 0.0;
                                        let index = 0;

                                        for (let item of collection) {
                                            const probability = func(item);

                                            if (sum <= r && r < sum + probability) {
                                                break;
                                            }

                                            sum += probability;
                                            index++;
                                        }

                                        return collection[index];
                                    }

                                    function softmax(x, func1, func2) {
                                        const y = [].concat(x);
                                        let max = Number.MIN_VALUE;
                                        let sum = 0.0;

                                        for (let i = 0; i < x.length; i++) {
                                            if (func1(x[i]) > max) {
                                                max = func1(x[i]);
                                            }
                                        }

                                        for (let i = 0; i < x.length; i++) {
                                            sum += Math.exp(func1(x[i]) - max);
                                        }

                                        for (let i = 0; i < x.length; i++) {
                                            func2(y[i], Math.exp(func1(x[i]) - max) / sum);
                                        }

                                        return y;
                                    }

                                    const dictionary = snapshot.val();
                                    const images = [];

                                    for (const key in dictionary) {
                                        dictionary[key]["probability"] = 1;

                                        images.push(dictionary[key]);
                                    }

                                    const path = choice(softmax(images, x => x.probability, (x, y) => x.probability = y), x => x.probability).path;
                                    const metadata = await getMetadata(storageRef(storage, path));

                                    if (metadata.contentType.startsWith("image/")) {
                                        for (const item of background.dataset) {
                                            if ("type" in item === false && "images" in item) {
                                                item.images.push({ color: "#ffffff", frames: [{ delay: 0, source: `gs://milchchan.appspot.com/${path}` }] });
                                            }
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error(error);
                            }

                            if ("images" in background.dataset[background.index] && background.dataset[background.index].images.length > 0) {
                                if (background.queue.some(x => x.index !== background.index)) {
                                    background.queue.splice(0);
                                }

                                if (background.queue.length === 0) {
                                    const boundary = background.dataset[background.index].images.reduce((x, y) => y.frames.some(z => z.source.startsWith("gs:")) ? x : x + 1, 0);

                                    for (const image of background.dataset[background.index].images.length > boundary ? [background.dataset[background.index].images[random(0, boundary)], background.dataset[background.index].images[random(boundary, background.dataset[background.index].images.length)]] : shuffle(background.dataset[background.index].images)) {
                                        background.queue.push({ index: background.index, data: image });
                                    }
                                }

                                const data = background.queue.shift().data;
                                const blind = document.createElement("div");
                                const progress = document.createElement("div");
                                const bar = document.createElement("div");
                                const timeout = 60 * 60;
                                let index = 0;

                                blind.className = "blind";
                                blind.style.transform = "translate3d(0, 100%, 0)";

                                try {
                                    const response = await fetch(window.devicePixelRatio > 1 ? `images/Background@${window.devicePixelRatio}x.png` : "images/Background.png");

                                    if (response.ok) {
                                        const blob = await response.blob();
                                        const dataURL = await new Promise(async (resolve, reject) => {
                                            const reader = new FileReader();

                                            reader.onload = () => {
                                                resolve(reader.result);
                                            };
                                            reader.onerror = () => {
                                                reject(reader.error);
                                            };
                                            reader.readAsDataURL(blob);
                                        });
                                        blind.style.backgroundImage = `url('${dataURL}')`;
                                    }
                                } catch (error) {
                                    console.error(error);
                                }

                                document.body.querySelector("#app>.container>.wrap>.frame>.wall").after(blind);

                                await new Promise(async (resolve) => {
                                    blind.animate([
                                        {
                                            transform: "translate3d(0, 0%, 0)"
                                        }
                                    ], {
                                        delay: 0,
                                        fill: "forwards",
                                        duration: 500,
                                        iterations: 1,
                                        easing: "ease-out"
                                    }).onfinish = () => {
                                        blind.style.transform = "translate3d(0, 0%, 0)";

                                        resolve();
                                    };
                                });

                                progress.className = "progress";
                                bar.className = "bar animating";
                                bar.style.width = "0%";

                                try {
                                    const response = await fetch(window.devicePixelRatio > 1 ? `images/Stripes@${window.devicePixelRatio}x.png` : "images/Stripes.png");

                                    if (response.ok) {
                                        const dataURL = await new Promise(async (resolve, reject) => {
                                            const reader = new FileReader();

                                            reader.onload = () => {
                                                resolve(reader.result);
                                            };
                                            reader.onerror = () => {
                                                reject(reader.error);
                                            };
                                            reader.readAsDataURL(await response.blob());
                                        });

                                        if (dataURL !== null) {
                                            bar.style.backgroundImage = `url('${dataURL}')`;
                                        }
                                    }
                                } catch (error) {
                                    console.error(error);
                                }

                                progress.appendChild(bar);
                                document.body.querySelector("#app").appendChild(progress);

                                if ("color" in data) {
                                    background.color = data.color;
                                } else {
                                    background.color = null;
                                }

                                for (const frame of data.frames) {
                                    const timestamp = Math.floor(new Date() / 1000);

                                    if (frame.source in cache === false || timestamp - cache[frame.source].timestamp >= timeout) {
                                        const blob = await download(frame.source.startsWith("gs:") ? await getDownloadURL(storageRef(storage, frame.source)) : frame.source, (rate) => {
                                            if (index < data.frames.length - 1 || rate < 1) {
                                                bar.animate([
                                                    {
                                                        width: `${Math.floor((rate / data.frames.length + index / data.frames.length) * 100)}%`
                                                    }
                                                ], {
                                                    delay: 0,
                                                    fill: "forwards",
                                                    duration: 500,
                                                    iterations: 1,
                                                    easing: "linear",
                                                    composite: "replace"
                                                }).onfinish = () => {
                                                    bar.style.width = `${Math.floor((index + 1) / data.frames.length * 100)}%`;
                                                };
                                            } else {
                                                bar.animate([
                                                    {
                                                        width: `${Math.floor((index + 1) / data.frames.length * 100)}%`
                                                    }
                                                ], {
                                                    delay: 0,
                                                    fill: "forwards",
                                                    duration: 500,
                                                    iterations: 1,
                                                    easing: "ease-in",
                                                    composite: "replace"
                                                }).onfinish = () => {
                                                    bar.style.width = `${Math.floor((index + 1) / data.frames.length * 100)}%`;
                                                    bar.animate([
                                                        {
                                                            opacity: 0
                                                        }
                                                    ], {
                                                        delay: 0,
                                                        fill: "forwards",
                                                        duration: 500,
                                                        iterations: 1,
                                                        easing: "ease-in"
                                                    }).onfinish = () => {
                                                        progress.remove();
                                                    };
                                                };
                                            }
                                        });

                                        if (blob === null) {
                                            if (index === data.frames.length - 1) {
                                                bar.animate([
                                                    {
                                                        opacity: 0
                                                    }
                                                ], {
                                                    delay: 0,
                                                    fill: "forwards",
                                                    duration: 500,
                                                    iterations: 1,
                                                    easing: "ease-in",
                                                    composite: "replace"
                                                }).onfinish = () => {
                                                    progress.remove();
                                                };
                                            }
                                        } else {
                                            try {
                                                const animation = ["image/apng", "image/png"].includes(blob.type) ? await new APNG().load(blob) : null;

                                                if (animation === null) {
                                                    const image = await new Promise(async (resolve, reject) => {
                                                        const reader = new FileReader();

                                                        reader.onload = () => {
                                                            const image = new Image();

                                                            image.onload = () => {
                                                                resolve(image);
                                                            };
                                                            image.onerror = (error) => {
                                                                reject(error);
                                                            };
                                                            image.crossOrigin = "anonymous";
                                                            image.src = reader.result;
                                                        };
                                                        reader.onerror = () => {
                                                            reject(reader.error);
                                                        };
                                                        reader.readAsDataURL(blob);
                                                    });

                                                    animationQueue.push(Object.assign({ time: 0, image: image }, frame));
                                                    cache[frame.source] = { image: image, timestamp: timestamp };
                                                } else {
                                                    const frames = [];

                                                    for (const frame of animation[0]) {
                                                        frames.push({
                                                            delay: frame.delay, image: await new Promise(async (resolve, reject) => {
                                                                const reader = new FileReader();

                                                                reader.onload = () => {
                                                                    const image = new Image();

                                                                    image.onload = () => {
                                                                        resolve(image);
                                                                    };
                                                                    image.onerror = (error) => {
                                                                        reject(error);
                                                                    };
                                                                    image.crossOrigin = "anonymous";
                                                                    image.src = reader.result;
                                                                };
                                                                reader.onerror = () => {
                                                                    reject(reader.error);
                                                                };
                                                                reader.readAsDataURL(frame.blob);
                                                            })
                                                        });
                                                    }

                                                    if (frames.length > 0) {
                                                        for (let i = 1; i < animation[1]; i++) {
                                                            for (let j = 0; j < frames.length; j++) {
                                                                frames.push(frames[j]);
                                                            }
                                                        }

                                                        frames[frames.length - 1].delay += frame.delay;

                                                        for (const frame of frames) {
                                                            animationQueue.push(Object.assign({ time: 0 }, frame));
                                                        }

                                                        cache[frame.source] = { frames: frames, timestamp: timestamp };
                                                    }
                                                }
                                            } catch (error) {
                                                console.error(error);
                                            }
                                        }
                                    } else {
                                        if (index < data.frames.length - 1) {
                                            bar.animate([
                                                {
                                                    width: `${Math.floor((index + 1) / data.frames.length * 100)}%`
                                                }
                                            ], {
                                                delay: 0,
                                                fill: "forwards",
                                                duration: 500,
                                                iterations: 1,
                                                easing: "ease-in",
                                                composite: "replace"
                                            }).onfinish = () => {
                                                bar.style.width = `${Math.floor((index + 1) / data.frames.length * 100)}%`;
                                            };
                                        } else {
                                            bar.animate([
                                                {
                                                    width: `${Math.floor((index + 1) / data.frames.length * 100)}%`
                                                }
                                            ], {
                                                delay: 0,
                                                fill: "forwards",
                                                duration: 500,
                                                iterations: 1,
                                                easing: "ease-in",
                                                composite: "replace"
                                            }).onfinish = () => {
                                                bar.style.width = `${Math.floor((index + 1) / data.frames.length * 100)}%`;
                                                bar.animate([
                                                    {
                                                        opacity: 0
                                                    }
                                                ], {
                                                    delay: 0,
                                                    fill: "forwards",
                                                    duration: 500,
                                                    iterations: 1,
                                                    easing: "ease-in"
                                                }).onfinish = () => {
                                                    progress.remove();
                                                };
                                            };
                                        }

                                        if ("frames" in cache[frame.source]) {
                                            for (const data of cache[frame.source].frames) {
                                                animationQueue.push(Object.assign({ time: 0 }, data));
                                            }
                                        } else {
                                            animationQueue.push(Object.assign({ time: 0, image: cache[frame.source].image }, frame));
                                        }
                                    }

                                    index++;
                                }

                                for (let i = animationQueue.length - 2; i >= 0; i--) {
                                    animationQueue.push(animationQueue[i]);
                                }

                                blind.animate([
                                    {
                                        transform: "translate3d(0, -100%, 0)"
                                    }
                                ], {
                                    delay: 0,
                                    fill: "forwards",
                                    duration: 500,
                                    iterations: 1,
                                    easing: "ease-out",
                                    composite: "replace"
                                }).onfinish = () => {
                                    blind.remove();
                                };
                            } else {
                                background.color = null;
                            }

                            background.preloading = false;

                            const length = random(8, 16);
                            let start = background.dataset[background.index].texts.length - length;
                            let samples;

                            if (start >= 0) {
                                start = random(0, start);
                                samples = background.dataset[background.index].texts.slice(start, start + length);
                            } else {
                                samples = background.dataset[background.index].texts;
                            }

                            for (const sample of samples) {
                                let text;
                                const attributes = [];
                                const source = [];
                                const letters = [];

                                if (typeof (sample) === "string") {
                                    text = sample.replace(/\r?\n/g, "");
                                    source.push(text);
                                } else {
                                    text = Object.keys(sample).sort((x, y) => x - y).reduce((x, y) => {
                                        if (typeof (sample[y]) === "string") {
                                            const s = sample[y].replace(/\r?\n/g, "");

                                            x.text += s;

                                            if (x.source.length > 0 && typeof (x.source[x.source.length - 1]) === "string") {
                                                x.source[x.source.length - 1] += s;
                                            } else {
                                                x.source.push(s);
                                            }
                                        } else if (Array.isArray(sample[y])) {
                                            const s = sample[y].reduce((a, b) => a + (typeof (b) === "string" ? b : b.name).replace(/\r?\n/g, ""), "");

                                            x.attributes.push({ start: x.text.length, end: x.text.length + s.length });
                                            x.text += s;
                                            x.source.push({ name: s });
                                        } else {
                                            const text = sample[y].name.replace(/\r?\n/g, "");

                                            x.attributes.push({ start: x.text.length, end: x.text.length + text.length });
                                            x.text += text;
                                            x.source.push({ name: text });
                                        }

                                        return x;
                                    }, { text: "", attributes: attributes, source: source }).text;
                                }

                                for (let i = 0; i < text.length; i++) {
                                    if (letters.indexOf(text.charAt(i)) === -1 && text.charAt(i) !== "\n" && text.charAt(i).match(/\s/) === null) {
                                        letters.push(text.charAt(i));
                                    }
                                }

                                background.blocks.push({
                                    height: 100 / samples.length,
                                    colors: { main: window.getComputedStyle(document.documentElement).getPropertyValue("--background-color"), accent: window.getComputedStyle(document.documentElement).getPropertyValue("--background-color") },
                                    inlines: [
                                        { running: true, time: 0, duration: null, type: { elapsed: -1, speed: 30, reverse: false, buffer: "", count: 0 }, text: text, attributes: attributes, characters: [], source: source, letters: letters }
                                    ],
                                    elapsed: 0,
                                });
                            }
                        }

                        for (const block of background.blocks) {
                            let index = 0;

                            for (const inline of block.inlines) {
                                if (inline.running) {
                                    if (inline.type.reverse) {
                                        if (inline.type.count > 0) {
                                            inline.type.elapsed += deltaTime * 2;

                                            if (inline.type.elapsed >= 1.0 / inline.type.speed) {
                                                let index = inline.type.count - 1;

                                                if (index < inline.text.length) {
                                                    const width = Math.floor(inline.text.length / 2);

                                                    if (inline.type.buffer.length <= width && inline.type.count > 0) {
                                                        inline.type.count -= 1;
                                                    }

                                                    if (inline.type.buffer.length > 0) {
                                                        inline.type.buffer = inline.type.buffer.substring(0, inline.type.buffer.length - 1);
                                                    }
                                                }

                                                inline.type.elapsed = 0;
                                            }
                                        } else {
                                            inline.time = 0;
                                            inline.type.elapsed = -1;
                                            inline.type.reverse = false;
                                            inline.running = false;
                                        }
                                    } else if (inline.type.buffer.length < inline.text.length) {
                                        if (inline.type.elapsed >= 0) {
                                            inline.type.elapsed += deltaTime;
                                        } else {
                                            inline.type.elapsed = deltaTime;
                                        }

                                        if (inline.type.elapsed >= 1.0 / inline.type.speed) {
                                            const index = inline.type.buffer.length;
                                            const width = Math.floor(inline.text.length / 2);
                                            const length = inline.text.length;

                                            if (inline.type.count >= width) {
                                                inline.type.buffer += inline.text.charAt(index);
                                            }

                                            if (inline.type.count < length) {
                                                inline.type.count += 1;
                                            }

                                            inline.type.elapsed = 0;
                                        }
                                    } else {
                                        inline.time += deltaTime;

                                        if (inline.duration !== null && inline.time >= inline.duration) {
                                            inline.type.reverse = true;
                                        }
                                    }

                                    if (inline.text.length === inline.type.buffer.length) {
                                        const characters = inline.text.split("");

                                        inline.characters.splice(0);

                                        for (let i = 0; i < characters.length; i++) {
                                            inline.characters.push({ key: i, value: characters[i], highlight: inline.attributes.some(x => i >= x.start && i < x.end) });
                                        }
                                    } else {
                                        const charArray = inline.letters;
                                        let randomBuffer = "";

                                        if (charArray.length > 0) {
                                            for (let i = 0; i < inline.type.count; i++) {
                                                if (inline.text.charAt(i) === "\n") {
                                                    randomBuffer += "\n";
                                                } else {
                                                    randomBuffer += charArray[~~random(0, charArray.length)];
                                                }
                                            }
                                        }

                                        if (randomBuffer.length > inline.type.buffer.length) {
                                            const characters = (inline.type.buffer + randomBuffer.substring(inline.type.buffer.length, randomBuffer.length)).split("");

                                            inline.characters.splice(0);

                                            for (let i = 0; i < characters.length; i++) {
                                                inline.characters.push({ key: i, value: characters[i], highlight: inline.attributes.some(x => i >= x.start && i < x.end) });
                                            }
                                        } else if (inline.characters.length !== inline.type.buffer.length) {
                                            const characters = inline.type.buffer.split("");

                                            inline.characters.splice(0);

                                            for (let i = 0; i < characters.length; i++) {
                                                inline.characters.push({ key: i, value: characters[i], highlight: inline.attributes.some(x => i >= x.start && i < x.end) });
                                            }
                                        }
                                    }
                                }

                                index++;
                            }

                            block.elapsed += deltaTime;
                        }

                        const backCanvas = canvas.backBuffer;

                        backCanvas.width = canvas.width;
                        backCanvas.height = canvas.height;

                        const backContext = backCanvas.getContext("2d");
                        const frontContext = canvas.getContext("2d");
                        const margin = 16;
                        const lineHeight = backCanvas.height / background.blocks.length;
                        const fontSize = Math.floor(lineHeight / 2);
                        const fontFamily = window.getComputedStyle(document.documentElement).getPropertyValue("--background-font-family");
                        let index = 0;

                        backContext.imageSmoothingEnabled = true;
                        backContext.imageSmoothingQuality = "high";
                        backContext.textAlign = "left";
                        backContext.textBaseline = "middle";
                        backContext.clearRect(0, 0, backCanvas.width, backCanvas.height);
                        backContext.save();
                        backContext.beginPath();

                        for (const block of background.blocks) {
                            for (const inline of block.inlines) {
                                if (inline.running && inline.characters.length > 0) {
                                    const line = [{ text: inline.characters[0].value, highlight: inline.characters[0].highlight }];
                                    let width = 0;
                                    let offset = 0;

                                    for (let i = 1; i < inline.characters.length; i++) {
                                        if (inline.characters[i].highlight) {
                                            if (line[line.length - 1].highlight) {
                                                line[line.length - 1].text += inline.characters[i].value;
                                            } else {
                                                line.push({ text: inline.characters[i].value, highlight: true });
                                            }
                                        } else if (line[line.length - 1].highlight) {
                                            line.push({ text: inline.characters[i].value, highlight: false });
                                        } else {
                                            line[line.length - 1].text += inline.characters[i].value;
                                        }
                                    }

                                    backContext.save();
                                    backContext.font = `${fontSize}px ${fontFamily}`;

                                    for (const s of inline.source) {
                                        const textMetrics = backContext.measureText(typeof (s) === "string" ? s : s.name);

                                        width += Math.abs(textMetrics.actualBoundingBoxLeft) + Math.abs(textMetrics.actualBoundingBoxRight) + margin;
                                    }

                                    backContext.translate(block.elapsed % 60 / 60 * -width, 0);

                                    do {
                                        for (let i = 0; i < 2; i++) {
                                            let x = 0;

                                            for (const segment of line) {
                                                if (segment.highlight) {
                                                    backContext.globalAlpha = 1.0;
                                                    backContext.fillStyle = `${block.colors.accent}`;
                                                } else {
                                                    backContext.globalAlpha = 1.0;
                                                    backContext.fillStyle = `${block.colors.main}`;
                                                }

                                                const textMetrics = backContext.measureText(segment.text);

                                                backContext.fillText(segment.text, Math.round(offset + x - textMetrics.actualBoundingBoxLeft), Math.round(lineHeight * index + (lineHeight - fontSize) / 2 + fontSize / 2));// - textMetrics.actualBoundingBoxDescent + (fontSize - textMetrics.actualBoundingBoxAscent) / 2));

                                                x += Math.abs(textMetrics.actualBoundingBoxLeft) + Math.abs(textMetrics.actualBoundingBoxRight) + margin;
                                            }

                                            for (const s of inline.source) {
                                                const textMetrics = backContext.measureText(typeof (s) === "string" ? s : s.name);

                                                offset += Math.abs(textMetrics.actualBoundingBoxLeft) + Math.abs(textMetrics.actualBoundingBoxRight) + margin;
                                            }
                                        }
                                    } while (offset - margin < backCanvas.width * 2);

                                    backContext.restore();
                                }
                            }

                            index++;
                        }

                        if (background.particles.length > 0) {
                            backContext.save();

                            for (let i = background.particles.length - 1; i >= 0; i--) {
                                const particle = background.particles[i];

                                if (particle.elapsed >= 0) {
                                    particle.elapsed += deltaTime;
                                } else {
                                    particle.elapsed = deltaTime;
                                    particle["radius"] = Math.random() * 64;
                                    particle["degrees"] = Math.random() * 360;
                                    particle["duration"] = Math.random() * 2.5 + 0.5;
                                }

                                if (particle.elapsed >= particle.duration) {
                                    background.particles.pop();
                                } else {
                                    const step = Math.sin(particle.elapsed / particle.duration * Math.PI);
                                    const scale = window.devicePixelRatio * step;

                                    backContext.save();
                                    backContext.scale(scale, scale);
                                    backContext.translate(-particle.image.width / 2 + Math.round(particle.x + Math.cos(Math.PI / 180 * particle.degrees) * particle.radius) * window.devicePixelRatio / scale, -particle.image.height / 2 + Math.round(particle.y + Math.sin(Math.PI / 180 * particle.degrees) * particle.radius) * window.devicePixelRatio / scale);
                                    backContext.globalAlpha = step;
                                    backContext.drawImage(particle.image, 0, 0, particle.image.width, particle.image.height, 0, 0, particle.image.width, particle.image.height);
                                    backContext.restore();
                                }
                            }
                        }

                        backContext.closePath();
                        backContext.globalCompositeOperation = "source-atop";

                        if (background.color === null) {
                            backContext.fillStyle = window.getComputedStyle(document.documentElement).getPropertyValue("--background-color");
                        } else {
                            backContext.fillStyle = background.color;
                        }

                        backContext.fillRect(0, 0, backCanvas.width, backCanvas.height);

                        if (!tracker.active && (tracker.velocity.x !== 0 || tracker.velocity.y !== 0)) {
                            const decelerationRate = 10 * 96 / 1000;

                            if (tracker.velocity.x > 1000) {
                                tracker.velocity.x = 1000;
                            } else if (tracker.velocity.x < -1000) {
                                tracker.velocity.x = -1000;
                            }

                            if (tracker.velocity.y > 1000) {
                                tracker.velocity.y = 1000;
                            } else if (tracker.velocity.y < -1000) {
                                tracker.velocity.y = -1000;
                            }

                            tracker.velocity.x -= tracker.velocity.x * decelerationRate * deltaTime;
                            tracker.velocity.y -= tracker.velocity.y * decelerationRate * deltaTime;

                            if (Math.abs(tracker.velocity.x) < 0.001) {
                                tracker.velocity.x = 0;
                            }

                            if (Math.abs(tracker.velocity.y) < 0.001) {
                                tracker.velocity.y = 0;
                            }

                            tracker.movement.x += tracker.velocity.x * deltaTime;
                            tracker.movement.y += tracker.velocity.y * deltaTime;
                        }

                        if (animationQueue.length > 0) {
                            let count = animationQueue.length;
                            let frame = animationQueue[0];
                            let delay = Math.max(frame.delay, 0.01);

                            frame.time += deltaTime;

                            while (frame.time >= delay) {
                                const time = frame.time - delay;

                                frame.time = 0;
                                animationQueue.push(animationQueue.shift());
                                frame = animationQueue[0];
                                count--;

                                if (count > 0) {
                                    frame.time += time;
                                } else {
                                    break;
                                }

                                delay = Math.max(frame.delay, 0.01);
                            }

                            if (frame.image !== null) {
                                const top = 0;
                                const left = 0.5;
                                const canvasAspect = backCanvas.width / backCanvas.height;
                                const imageAspect = frame.image.width / frame.image.height;
                                let sx, sy, sw, sh;

                                if (canvasAspect > imageAspect) {
                                    const ratio = backCanvas.width / frame.image.width;

                                    sx = 0;
                                    sh = backCanvas.height / ratio;
                                    sy = Math.max(0, Math.min(frame.image.height - sh, (frame.image.height * ratio - backCanvas.height) / ratio * top - tracker.movement.y * window.devicePixelRatio / ratio));
                                    sw = frame.image.width;

                                    const insetTop = (frame.image.height * ratio - backCanvas.height) * top / window.devicePixelRatio;
                                    const insetBottom = (backCanvas.height - frame.image.height * ratio + (frame.image.height * ratio - backCanvas.height) * top) / window.devicePixelRatio;

                                    if (insetTop < tracker.movement.y) {
                                        if (tracker.active) {
                                            tracker.edge = true;
                                        } else if (!tracker.edge) {
                                            tracker.velocity.y *= -1;
                                        }

                                        tracker.movement.y = insetTop;
                                    } else if (insetBottom > tracker.movement.y) {
                                        if (tracker.active) {
                                            tracker.edge = true;
                                        } else if (!tracker.edge) {
                                            tracker.velocity.y *= -1;
                                        }

                                        tracker.movement.y = insetBottom;
                                    } else if (insetTop === tracker.movement.y || insetBottom === tracker.movement.y) {
                                        if (tracker.active) {
                                            tracker.edge = true;
                                        }
                                    } else {
                                        tracker.edge = false;
                                    }
                                } else {
                                    const ratio = backCanvas.height / frame.image.height;

                                    sw = backCanvas.width / ratio;
                                    sx = Math.max(0, Math.min(frame.image.width - sw, (frame.image.width * ratio - backCanvas.width) / ratio * left - tracker.movement.x * window.devicePixelRatio / ratio));
                                    sy = 0;
                                    sh = frame.image.height;

                                    const insetLeft = (frame.image.width * ratio - backCanvas.width) * left / window.devicePixelRatio;
                                    const insetRight = (backCanvas.width - frame.image.width * ratio + (frame.image.width * ratio - backCanvas.width) * left) / window.devicePixelRatio;

                                    if (insetLeft < tracker.movement.x) {
                                        if (tracker.active) {
                                            tracker.edge = true;
                                        } else if (!tracker.edge) {
                                            tracker.velocity.y *= -1;
                                        }

                                        tracker.movement.x = insetLeft;
                                    } else if (insetRight > tracker.movement.x) {
                                        if (tracker.active) {
                                            tracker.edge = true;
                                        } else if (!tracker.edge) {
                                            tracker.velocity.y *= -1;
                                        }

                                        tracker.movement.x = insetRight;
                                    } else if (insetLeft === tracker.movement.x || insetRight === tracker.movement.x) {
                                        if (tracker.active) {
                                            tracker.edge = true;
                                        }
                                    } else {
                                        tracker.edge = false;
                                    }
                                }

                                backContext.drawImage(frame.image, sx, sy, sw, sh, 0, 0, backCanvas.width, backCanvas.height);
                            }
                        }

                        backContext.restore();
                        frontContext.clearRect(0, 0, backCanvas.width, backCanvas.height);
                        frontContext.drawImage(backCanvas, 0, 0);

                        backCanvas.width = backCanvas.height = 0;
                    }

                    fps.frames++;

                    if (performance.now() - fps.time >= 1000) {
                        fps.target.innerText = String(fps.frames);
                        fps.time = performance.now();
                        fps.frames = 0;
                    }

                    requestAnimationFrame(render);
                }

                requestAnimationFrame(render);
            }
        });
        window.addEventListener("resize", event => {
            const wall = document.body.querySelector("#app>.container>.wrap>.frame>.wall");
            const canvas = wall.querySelector(":scope>canvas");
            const rect = wall.getBoundingClientRect();

            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
        });
        window.addEventListener("mousedown", event => {
            if (event.button === 0 && !tracker.touching) {
                const rect = document.body.querySelector("#app>.container>.wrap>.frame>.wall").getBoundingClientRect();
                const x = event.clientX - rect.x;
                const y = event.clientY - rect.y;
                const timestamp = event.timeStamp / 1000;

                tracker.active = true;
                tracker.position.x = x;
                tracker.position.y = y;
                tracker.timestamp = timestamp;
                tracker.velocity.x = tracker.velocity.y = 0;

                if (background.cache.length > 0 && !background.particles.some(x => timestamp - x.timestamp < 0.1)) {
                    for (let i = random(0, 4); i > 0; i--) {
                        background.particles.unshift({ elapsed: -1, x: x, y: y, image: background.cache[random(0, background.cache.length)], timestamp: timestamp });
                    }
                }
            }
        });
        window.addEventListener("mousemove", event => {
            if (tracker.active && !tracker.touching) {
                const rect = document.body.querySelector("#app>.container>.wrap>.frame>.wall").getBoundingClientRect();
                const x = event.clientX - rect.x;
                const y = event.clientY - rect.y;
                const timestamp = event.timeStamp / 1000;
                const deltaX = x - tracker.position.x;
                const deltaY = y - tracker.position.y;
                const deltaTime = timestamp - tracker.timestamp;

                tracker.position.x = x;
                tracker.position.y = y;
                tracker.timestamp = timestamp;
                tracker.movement.x += deltaX;
                tracker.movement.y += deltaY;

                if (deltaTime > 0) {
                    tracker.velocity.x = deltaX / deltaTime;
                    tracker.velocity.y = deltaY / deltaTime;
                }

                if (background.cache.length > 0 && !background.particles.some(x => timestamp - x.timestamp < 0.1)) {
                    for (let i = random(0, 4); i > 0; i--) {
                        background.particles.unshift({ elapsed: -1, x: x, y: y, image: background.cache[random(0, background.cache.length)], timestamp: timestamp });
                    }
                }
            }
        });
        window.addEventListener("mouseup", event => {
            if (event.button === 0 && !tracker.touching) {
                tracker.active = false;
            }
        });
        window.addEventListener("touchstart", event => {
            event.stopPropagation();

            const rect = document.body.querySelector("#app>.container>.wrap>.frame>.wall").getBoundingClientRect();
            const x = event.changedTouches[0].clientX - rect.x;
            const y = event.changedTouches[0].clientY - rect.y;
            const timestamp = event.timeStamp / 1000;

            tracker.active = true;
            tracker.touching = true;
            tracker.position.x = x;
            tracker.position.y = y;
            tracker.timestamp = timestamp;
            tracker.velocity.x = tracker.velocity.y = 0;

            if (background.cache.length > 0 && !background.particles.some(x => timestamp - x.timestamp < 0.1)) {
                for (let i = random(0, 4); i > 0; i--) {
                    background.particles.unshift({ elapsed: -1, x: x, y: y, image: background.cache[random(0, background.cache.length)], timestamp: timestamp });
                }
            }
        });
        window.addEventListener("touchmove", event => {
            event.stopPropagation();

            const rect = document.body.querySelector("#app>.container>.wrap>.frame>.wall").getBoundingClientRect();
            const x = event.changedTouches[0].clientX - rect.x;
            const y = event.changedTouches[0].clientY - rect.y;
            const timestamp = event.timeStamp / 1000;
            const deltaX = x - tracker.position.x;
            const deltaY = y - tracker.position.y;
            const deltaTime = timestamp - tracker.timestamp;

            tracker.position.x = x;
            tracker.position.y = y;
            tracker.timestamp = timestamp;
            tracker.movement.x += deltaX;
            tracker.movement.y += deltaY;

            if (deltaTime > 0) {
                tracker.velocity.x = deltaX / deltaTime;
                tracker.velocity.y = deltaY / deltaTime;
            }

            if (background.cache.length > 0 && !background.particles.some(x => timestamp - x.timestamp < 0.1)) {
                for (let i = random(0, 4); i > 0; i--) {
                    background.particles.unshift({ elapsed: -1, x: x, y: y, image: background.cache[random(0, background.cache.length)], timestamp: timestamp });
                }
            }
        });
        window.addEventListener("touchend", event => {
            event.stopPropagation();

            tracker.active = false;
            tracker.touching = false;
        });
        window.addEventListener("touchcancel", event => {
            event.stopPropagation();

            tracker.active = false;
            tracker.touching = false;
        });
    </script>
</body>

</html>